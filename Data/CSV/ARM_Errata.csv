Processor Name,Major Revision,Minor Revision,Category,Rare,Summary,Products Affected,Erratum Description,Configurations Affected,Conditions,Implications,Workaround
Cortex A-9,r4,p0,A,1,Possible inconsistent sequencing of read accesses to the same memory location,Cortex-A9 MPCore,"The ARM architecture and the general rules of coherency require reads to the same memory location to be observed in sequential order. Because of some internal replay path mechanisms, the Cortex-A9 can see one read access bypassed by a following read access to the same memory location, thus not observing the values in program order.",-,"The erratum requires a Cortex-A9 MPCore configuration with two or more processors or more. The erratum can occur only on a processor working in SMP mode, on memory regions marked as Normal Memory Write-Back Shared.",The erratum causes data coherency failure.,"The majority of multi-processing code examples follow styles that do not expose the erratum. Therefore, this erratum occurs rarely and is likely to  ffect only very specific areas of code that rely on a read-ordering behavior. There are two possible workarounds for this erratum. The first possible workaround is to use LDREX instead of standard LDR in volatile memory places that require a strict read ordering. The alternative possible workaround is the recommended workaround for tool chains integration. It requires insertion of a DMB between the affected LDR that requires this strict ordering rule. For more information about integrating the workaround inside tool chains, see the Programmer Advice Notice related to this erratum, ARM UAN 0004A."
Cortex A-9,r4,p0,B,0,Global Timer can send two interrupts for the same event,Cortex-A9 MPCore,"The Global Timer can be programmed to generate an interrupt request to the processor when it reaches a given programmed value. Because of the erratum, when you program the Global Timer to not use the auto-increment feature, it might generate two interrupt requests instead of one.",-,"The Global Timer Control register is programmed with the following settings. Bit[3] = 1'b0 - Global Timer is programmed in single-shot mode. Bit[2] = 1'b1 - Global Timer IRQ generation is enabled. Bit[1] = 1'b1 - Global Timer value comparison with Comparator registers is enabled. Bit[0] = 1'b1 - Global Timer count is enabled. With these settings, an IRQ is generated to the processor when the Global Timer value reaches the value programmed in the Comparator registers. The Interrupt Handler then performs the following sequence. Read the ICCIAR (Interrupt Acknowledge) register. Clear the Global Timer flag. Modify the comparator value, to set it to a higher value. Write the ICCEOIR (End of Interrupt) register. Under these conditions, because of the erratum the Global Timer might generate a second (spurious) interrupt request to the processor at the end of this Interrupt Handler sequence.",The erratum creates spurious interrupt requests in the system.,"Because the erratum happens only when the Global Timer is programmed in single-shot mode, that is, when it does not use the auto-increment feature, a first possible workaround is to program the Global Timer to use the auto-increment feature. If this first solution is not possible, a second workaround is to modify the Interrupt Handler to avoid the offending sequence. You can achieve this by clearing the Global Timer flag after incrementing the Comparator register value. The correct code sequence for the Interrupt Handler should then look like the following sequence. Read the ICCIAR (Interrupt Acknowledge) register. Modify the comparator value, to set it to a higher value. Clear the Global Timer flag. Clear the Pending Status information for Interrupt 27 (Global Timer interrupt) in the Distributor of the Interrupt Controller. Write the ICCEOIR (End of Interrupt) register."
Cortex A-9,r4,p0,B,0,Missed watchpoint on the second part of an unaligned access crossing a page boundary,"Cortex-A9, Cortex-A9 MPCore","Under rare conditions, a watchpoint might be undetected if it occurs on the second part of an unaligned access that crosses a 4K page boundary and misses in the μTLB for the second part of its request. The erratum requires a previous conditional instruction which accesses the second 4KB memory region (=where the watchpoint is set), which misses in the μTLB, and which is condition failed. The erratum also requires that no other μTLB miss occurs between this conditional failed instruction and the unaligned access, which implies that the unaligned access must hit in the μTLB for the first part of its access",-,-,A watchpoint does not trigger when it should.,"The erratum might occur in the case when a watchpoint is set on any of the first 3 bytes of a 4KB memory region, and unaligned accesses are not being faulted. The workaround is then to set a guard watchpoint on the last byte of the previous page, and to deal with any false positive matches if they occur."
Cortex A-9,r4,p0,B,0,Faulty MMU translations following ASID switch,"Cortex-A9, Cortex-A9 MPCore","A microTLB entry might be corrupted following an ASID switch, possibly corrupting subsequent MMU translations. The erratum requires execution of an explicit memory access, which might be speculative. This memory access misses in the TLB and cause a translation table walk. The erratum occurs when the translation table walk starts before the ASID switch code sequence, but completes after the ASID switch code sequence. In this case, a new entry is allocated in the microTLB for the TLB entry for this translation table walk, but corresponding to the old ASID. Because the microTLB does not record the ASID value, the new MMU translation, which should happen with the new ASID following the ASID switch, might hit this stale microTLB entry and become corrupted. Note that there is no Trustzone Security risk because the Security state of the access is held in the microTLB, and cannot be corrupted.",-,-,The erratum might cause MMU translation corruptions.,"The workaround for this erratum is to add a DSB in the ASID switch code sequence. The ARM architecture only mandates ISB before and after the ASID switch. Adding a DSB before the ASID switch ensures that the page table walk completes before the ASID change, so that no stale entry can be allocated in the microTLB. Modify the examples in the ARM Architecture Reference Manual for synchronizing the change in the ASID and TTBR as follows: The sequence: Change ASID to 0 ISB Change Translation Table Base Register ISB Change ASID to new value Becomes: DSB Change ASID to 0 ISB Change Translation Table Base Register ISB DSB Change ASID to new value. The sequence: Change Translation Table Base Register to the global-only mappings ISB Change ASID to new value ISB. Change Translation Table Base Register to new value Becomes: Change Translation Table Base Register to the global-only mappings ISB DSB Change ASID to new value ISB Change Translation Table Base Register to new value And the sequence: Set TTBCR.PD0 = 1 ISB Change ASID to new value Change Translation Table Base Register to new value ISB Set TTBCR.PD0 = 0 Becomes: Set TTBCR.PD0 = 1 ISB DSB Change ASID to new value Change Translation Table Base Register to new value ISB Set TTBCR.PD0 = 0"
Cortex A-9,r4,p0,B,0,Data or unified cache line maintenance by MVA fails on Inner Shareable memory,Cortex-A9 MPCore,"Under certain timing circumstances, a data or unified cache line maintenance operation by MVA that targets an Inner Shareable memory region might fail to propagate to either the Point of Coherency or to the Point of Unification of the system. As a consequence, the visibility of the updated data might not be guaranteed to either the instruction side, in the case of self-modifying code, or to an external non-coherent agent, such as a DMA engine.",-,"The erratum requires a Cortex-A9 MPCore configuration with two or more processors, working in SMP mode, with the broadcasting of CP15 maintenance operations enabled. The following scenario shows how the erratum can occur:  One CPU performs a data or unified cache line maintenance operation by MVA targeting a memory region which is locally dirty. A second CPU issues a memory request targeting this same memory location within the same time frame. A race condition can occur, resulting in the cache operation not being performed to the specified Point of Unification or Point of Coherence. The erratum affects the following maintenance operations: DCIMVAC: Invalidate data or unified cache line by MVA to PoC. DCCMVAC: Clean data or unified cache line by MVA to PoC DCCMVAU: Clean data or unified cache line by MVA to PoU. DCCIMVAC: Clean and invalidate data or unified cache line by MVA to PoC. The erratum can occur when the second CPU performs any of the following operations:. A read request resulting from any Load instruction; the Load might be a speculative one. A write request resulting from any Store instruction. A data prefetch resulting from a PLD instruction; the PLD might be a speculative one.","Because it is uncertain whether execution of the cache maintenance operation propagates to either the Point of Unification or the Point of Coherence, stale data might remain in the data cache and not become visible to other agents that should have gained visibility on it. Note that the data remains coherent on the L1 Data side. Any data read from another processor in the Cortex A9 MPCore cluster, or from the ACP, would see the correct data. In the same way, any write on the same cache line from another processor in the Cortex-A9 MPCore cluster, or from the ACP, does not cause a data corruption resulting from a loss of either data. Consequently, the failure can only impact non-coherent agents in the systems. This can be either the instruction cache of the processor, in the case of self-modifying code, or any non-coherent external agent in the system like a DMA.","Two workarounds are available for this erratum. The first workaround requires the three following elements to be applied altogether: Set bit[0] in the undocumented SCU Diagnostic Control register located at offset 0x30 from the PERIPHBASE address. Setting this bit disables the migratory bit feature. This forces a dirty cache line to be evicted to the lower memory subsystem, which is both the Point of Coherency and the Point of Unification, when it is being read by another processor. Note that this bit can be written, but is always Read as Zero. 2. Insert a DSB instruction before the cache maintenance operation. Note that, if the cache maintenance operation executes within a loop that performs no other memory operations, ARM recommends only adding a DSB before entering the loop. 3. Ensure there is no false sharing (on a cache line size alignment) for self-modifying code or for data produced for external non-coherent agent such as a DMA engine. For systems which cannot prevent false sharing in these regions, this third step can be replaced by performing the sequence of DSB followed by Cache maintenance operation twice. Note that even when all three components of the workaround are in place, the erratum might still occur. However, this would require some extremely rare and complex timing conditions, so that the probability of reaching the point of failure is extremely low. This, and the fact that the erratum requires an uncommon software scenario, explains why this workaround is likely to be a reliable practical solution for most systems. To ARM's knowledge, no failure has been observed in any system when all three components of this workaround have been implemented. For critical systems that cannot cope with the extremely low failure risks associated with the above workaround, a second workaround is possible which involves changing the mapping of the data being accessed so that it is in a Non-Cacheable area. This ensures that the written data remains uncached. This means it is always visible to non-coherent agents in the system, or to the instruction side in the case of self-modifying code, without any need for cache maintenance operation."
Cortex A-9,r4,p0,B,0,A short loop including a DMB instruction might cause a denial of service on another processor which executes a CP15 broadcast operation,Cortex-A9 MPCore,"A processor which continuously executes a short loop containing a DMB instruction might prevent a CP15 operation broadcast by another processor making further progress, causing a denial of service. ",This erratum affects all Cortex-A9 MPCore processors with two or more processors.,"The erratum requires the following conditions:  Two or more processors are working in SMP mode (ACTLR.SMP=1)  One of the processors continuously executes a short loop containing at least one DMB instruction.  Another processor executes a CP15 maintenance operation that is broadcast. This requires that this processor has enabled the broadcasting of CP15 operations (ACTLR.FW=1) For the erratum to occur, the short loop containing the DMB instruction must meet all of the following additional conditions:  No more than 10 instructions other than the DMB are executed between each DMB  No non-conditional Load or Store, or conditional Load or Store which pass the condition code check, are executed between each DMB When all the conditions for the erratum are met, the short loop is creating a continuous stream of DMB instructions. This might cause a denial of service, by preventing the processor executing the short loop from executing the received broadcast CP15 operation. As a result, the processor that originally executed the broadcast CP15 operation is stalled until the execution of the loop is interrupted. Note that because the process issuing the CP15 broadcast operation cannot complete operation, it cannot enter any debug-mode, and cannot take any interrupt. If the processor executing the short loop also cannot be interrupted, for example if it has disabled its interrupts, or if no interrupts are routed to this processor, this erratum might cause a system livelock. ","The erratum might create performance issues, or in the worst case it might cause a system livelock if the processor executing the DMB is in an infinite loop that cannot be interrupted. ","This erratum can be worked round by setting bit[4] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. This bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x10 MCR p15,0,rt,c15,c0,1 When it is set, this bit causes the DMB instruction to be decoded and executed like a DSB. Using this software workaround is not expected to have any impact on the overall performance of the processor on a typical code base. Other workarounds are also available for this erratum, to either prevent or interrupt the continuous stream of DMB instructions that causes the deadlock. For example: 2-24 Inserting a non-conditional Load or Store instruction in the loop between each DMBInserting additional instructions in the loop, such as NOPs, to avoid the processor seeing back to back DMB instructions. Making the processor executing the short loop take regular interrupts. "
Cortex A-9,r4,p0,B,0,Speculative instruction fetches with MMU disabled might not comply with architectural requirements,"Cortex-A9, Cortex-A9 MPCore","When the MMU is disabled, an ARMv7 processor must follow some architectural rules regarding speculative fetches and the addresses to which these can be initiated. These rules avoid potential read accesses to read-sensitive areas. For more information about these rules see the description of Behavior of instruction fetches when all associated MMUs are disabled in the ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition. A Cortex-A9 processor usually operates with both the MMU and branch prediction enabled. If the processor operates in this condition for any significant amount of time, the Branch Target Address Cache (BTAC) will contain branch predictions. If the MMU is then disabled, but branch prediction remains enabled, these stale BTAC entries can cause the processor to violate the rules for speculative fetches. ",This erratum affects all configurations of the processor.,"The erratum can occur only if the following sequence of conditions is met: 1. MMU and branch prediction are enabled. 2. Branches are executed. 3. MMU is disabled, and branch prediction remains enabled. ","If the above conditions occur, it is possible that after the MMU is disabled, speculative instruction fetches might occur to read-sensitive locations. ","The recommended workaround is to invalidate all entries in the BTAC, by executing an Invalidate Entire Branch Prediction Array (BPIALL) operation followed by a DSB, before disabling the MMU. Another possible workaround is to disable branch prediction when disabling the MMU, and keep branch prediction disabled until the MMU is re-enabled. "
Cortex A-9,r4,p0,B,0,"A write request to Uncacheable, Shareable normal memory region might be executed twice, possibly causing a software synchronisation issue","Cortex-A9, Cortex-A9 MPCore","Under certain timing circumstances specific to the Cortex-A9 microarchitecture, a write request to an Uncacheable, Shareable Normal memory region might be executed twice, causing the write request to be sent twice on the AXI bus. This might happen when the write request is followed by another write into the same naturally aligned doubleword memory region, without a DMB between the two writes. The repetition of the write usually has no impact on the overall behaviour of the system, unless the repeated write is used for synchronisation purposes. ",The erratum affects all configurations of the processor.,"The erratum requires the following conditions: 1. A write request is performed to an Uncacheable, Shareable Normal memory region. 2. Another write request is performed into the same naturally doubleword aligned memory region. This second write request must not be performed to the exact same bytes as the first store. A write request to Normal memory region is treated as Uncacheable in the following cases: The write request occurs while the Data Cache is disabled. The write request is targeting a memory region marked as Normal Memory Non-Cacheable or Cacheable Write-Through. The write request is targeting a memory region marked as Normal Memory Cacheable Write-Back and Shareable, and the CPU is in AMP mode. ","This erratum might have implications in a multi-master system where control information is passed between several processing elements in memory using a communication variable, for example a semaphore. In such a system, it is common for communication variables to be claimed using a Load-Exclusive/Store-Exclusive, but for the communication variable to be cleared using a non-Exclusive store. This erratum means that the clearing of such a communication variable might occur twice. This might lead to two masters apparently claiming a communication variable, and therefore might cause data corruption to shared data. A scenario in which this might happen is: MOV r1,#0x40; address is double-word aligned, mapped in ; Normal Non-cacheable Shareable memory Loop:LDREXr5, [r1,#0x0]; read the communication variable CMP r5, #0 ; check if 0 STREXEQ r5, r0, [r1]; attempt to store new value CMPEQ r5, #0; test if store succeeded BNE Loop; retry if not DMB ; ensures that all subsequent accesses are observed when gaining of the communication variable has been observed ; loads and stores in the critical region can now be performed MOV r2,#0 MOV r0, #0 DMB ; ensure all previous accesses are observed before the ; communication variable is cleared STR r0, [r1]; clear the communication variable with normal store STR r2, [r1,#0x4] ; previous STR might merge and be sent again, which might ; cause undesired release of the communication variable. This scenario is valid when the communication variable is a byte, a half-word, or a word ","There are several possible workarounds: Add a DMB after clearing a communication variable: STR r0, [r1]; clear the communication variable DMB ; ensure the previous STR is complete Also any IRQ or FIQ handler must execute a DMB at the start to ensure as well the clear of any communication variable is complete. Ensure there is no other data using the same naturally aligned 64-bit memory location as the communication variable: ALIGN 64 communication_variable DCD 0 unused_data DCD 0 LDR r1,= communication_variable ARM UAN 0009D ID032315 Use a Store-Exclusive to clear the communication variable, rather than a non-Exclusive store. "
Cortex A-9,r4,p0,B,1,"Under very rare timing circumstances, transitioning into streaming mode might create a data corruption",Cortex-A9 MPCore,"Under very rare timing circumstances, a data corruption might occur on a dirty cache line that is evicted from the L1 Data Cache due to another cache line being fully written. ",This erratum affects configurations with either: One processor if the ACP is present Two or more processors ,"The erratum requires the following conditions: The CPU contains a dirty line in its data cache. The CPU performs at least four full cache line writes, one of which causes the eviction of the dirty line. Another CPU, or the ACP, performs a read or write operation on the dirty line. The defect requires very rare timing conditions to reach the point of failure. These timing conditions depend on the CPU micro-architecture and are not controllable in software: The CPU must be in a transitional mode that might be triggered by the detection of the first two full cache line writes. The evicted line must remain stalled in the eviction buffer, which is likely to be caused by congested write traffic. The other coherent agent, either another CPU in the cluster or the ACP, must perform its coherency request on the evicted line while it is in the eviction buffer. ",The erratum might lead to data corruption.,"This erratum can be worked round by setting bit[22] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. The bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x00400000 MCR p15,0,rt,c15,c0,1 When this bit is set, the processor is unable to switch into Read-Allocate (streaming) mode, which means this erratum cannot occur. Setting this bit could possibly result in a visible drop in performance for routines that perform intensive memory accesses, such as memset() or memcpy(). However, the workaround is not expected to create any significant performance degradation in most standard applications. "
Cortex A-9,r4,p0,C,0,ISB is counted in Performance Monitor events 0x0C and 0x0D,"Cortex-A9, Cortex-A9 MPCore","The ISB is implemented as a branch in the Cortex-A9 micro-architecture. This implies that events 0x0C (software change of PC) and 0x0D (immediate branch) are asserted when an ISB occurs, which is not compliant with the ARM Architecture. ",-,-,"The count of events 0x0C and 0x0D are not completely precise when using the Performance Monitor counters, because the ISB is counted together with the real software changes to PC (for 0x0C ) and immediate branches ( 0x0D ). The erratum also causes the corresponding PMUEVENT bits to toggle in case an ISB executes. PMUEVENT[13] relates to event 0x0C PMUEVENT[14] relates to event 0x0D . ","You can count ISB instructions alone with event 0x90 . You can subtract this ISB count from the results you obtained in events 0x0C and 0x0D , to obtain the precise count of software change of PC ( 0x0C ) and immediate branches ( 0x0D ). "
Cortex A-9,r4,p0,C,0,Main ID register alias addresses are not mapped on Debug APB interface,"Cortex-A9, Cortex-A9 MPCore","The ARM Debug Architecture specifies registers 838 and 839 as Alias of the Main ID register. They should be accessible using the APB Debug interface at addresses 0xD18 and 0xD1C . The two alias addresses are not implemented in Cortex-A9. A read access at either of these two addresses returns 0, instead of the MIDR value. Read accesses to these two registers using the internal CP14 interface are trapped to UNDEFINED , which is compliant with the ARM Debug architecture. Therefore the erratum only applies to the alias addresses using the external Debug APB interface. ",-,-,"If the debugger, or any other external agent, tries to read the MIDR register using the alias addresses, it will get a faulty answer ( 0x0 ), which can cause indeterminate errors in the debugger afterwards. ","The workaround for this erratum is to always access the MIDR at its original address, 0xD00 , and not to use its alias address. "
Cortex A-9,r4,p0,C,0,"In debug state, next instruction is stalled when SDABORT flag is set, instead of being discarded","Cortex-A9, Cortex-A9 MPCore","When the processor is in debug state, an instruction written to the ITR after a Load/Store instruction that aborts gets executed on clearing the SDABORT_l, instead of being discarded. ",-,"Debugger has put the extDCCmode bits into Stall mode A previously issued load/store instruction has generated a synchronous Data Abort (for example, an MMU fault) For efficiency, the debugger does not read DBGDSCRext immediately, to see if the load/store has completed and has not aborted, but writes further instructions to the ITR, expecting them to be discarded if a problem occurs The debugger reads the DBGDSCR at the end of the sequence and discovers the load/store aborted The debugger clears the SDABORT_l flag (by writing to the Clear Sticky Aborts bit in DBGDRCR). Under these conditions, the instruction that follows in the ITR might execute instead of being discarded. ","Indeterminate failures can occur because of the instruction being executed when it should not. In most cases, it is unlikely that the failure will cause any significant issue. ","There are a selection of workarounds with increasing complexity and decreasing impact. In each case the impact is a loss of performance when debugging: 1. Do not use stall mode. 2. Do not use stall mode when doing load/store operations. 3. Always check for a sticky abort after issuing a load/store operation in stall mode (the cost of this probably means workaround number 2 is a preferred alternative). 4. Always check for a sticky abort after issuing a load/store operation in stall mode before issuing any further instructions that might corrupt an important target state (such as further load/store instructions, instructions that write to live registers such as VFP, CP15). "
Cortex A-9,r4,p0,C,0,DBGPCSR format is incorrect,"Cortex-A9, Cortex-A9 MPCore","With respect to the DBGPCSR register, the ARM Architecture specifies that: DBGPCSR[31:2] contain the sampled value of bits [31:2] of the PC. The sampled value is an instruction address plus an offset that depends on the processor instruction set state. DBGPCSR[1:0] contain the meaning of PC Sample Value, with the following permitted values: 0b00 ((DBGPCSR[31:2] << 2) – 8) references an ARM state instruction 0bx1 ((DBGPCSR[31:1] << 1) – 4) references a Thumb or ThumbEE state instruction 0b10 IMPLEMENTATION DEFINED. This field encodes the processor instruction set state, so that the profiling tool can calculate the true instruction address by subtracting the appropriate offset from the value sampled in bits [31:2] of the register. In Cortex-A9, the DBGPCSR samples the target address of executed branches (but possibly still speculative to data aborts), with the following encodings: DBGPCSR[31:2] contain the address of the target branch instruction, with no offset. DBGPCSR[1:0] contains the execution state of the target branch instruction: 0b00 for an ARM state instruction 0b01 for a Thumb state instruction 0b10 for a Jazelle state instruction 0b11 for a ThumbEE state instruction ",-,-,"The implication of this erratum is that the debugger tools must not rely on the architected description for the value of DBGPCSR[1:0], nor remove any offset from DBGPCSR[31:2], to obtain the expected PC value. Subtracting 4 or 8 from the DBGPCSR[31:2] value would lead to an area of code which is unlikely to have been recently executed, or which might not contain any executable code. The same might be true for Thumb instructions at half-word boundaries, in which case PC[1]=1 but DBGPCSR[1]=0, or ThumbEE instructions at word boundaries, with PC[1]=0 and DBGPCSR[1]=1. In Cortex-A9, because the DBGPCSR is always a branch target (= start of a basic block to the tool), the debugger should be able to spot many of these cases and attribute the sample to the right basic block. ","The debugger tools can find the expected PC value and instruction state by reading the DBGPCSR register, and consider it as described in the Description section. "
Cortex A-9,r4,p0,C,0,An imprecise abort might be reported twice on non-cacheable reads,"Cortex-A9, Cortex-A9 MPCore","In the case when two outstanding read memory requests to device or non-cacheable normal memory regions are issued by the Cortex-A9, and the first one receives an imprecise external abort, then the second access might falsely report an imprecise external abort. ",-,The erratum can only happen in systems which can generate imprecise external aborts on device or non-cacheable normal memory regions accesses. ,"When the erratum occurs, a second, spurious imprecise abort might be reported to the core when it should not. In practice, the failure is unlikely to cause any significant issues to the system because imprecise aborts are usually unrecoverable failures. Because the spurious abort can only happen following a first imprecise abort, either the first abort is ignored - and the spurious abort is then ignored too -, or it is acknowledged and probably generates a critical failure in the system, such as a processor reset or whole system reboot. ",There is no practical software workaround for the erratum.
Cortex A-9,r4,p0,C,0,Repeated Store in the same cache line might delay the visibility of the Store,"Cortex-A9, Cortex-A9 MPCore","Since r2p0 revision, the Cortex-A9 implements a small counter which ensures the external visibility of all stores in a finite amount of time, causing an eventual drain of the Merging Store Buffer. This is to avoid erratum #754327, where written data could potentially remain indefinitely in the Store Buffer. This Store Buffer has merging capabilities, and continues to merge data as long as the write accesses are performed in the same cache line. The issue which causes this erratum is that the draining counter resets each time a new data merge is performed. In the case when a code sequence loops, and continues to write data in this same cache line, then the external visibility of the written data might not be ensured. A livelock situation might consequently occur if any external agent is relying on the visibility of the written data, and where the writing processor cannot be interrupted while doing its writing loop. ",-,"The erratum can only happen on Normal Memory regions. The following examples describe scenarios that might trigger the erratum: 1. The processor continues incrementing a counter, writing the same word at the same address. The external agent (possibly another processor) polls on this address, waiting for any update of the counter value to proceed. The Store Buffer continues merging the updated value of the counter in its cache line, so that the external agent never sees any updated value, possibly leading to livelock. 2. The processor writes a value in a given word to indicate completion of its task, then continues writing data in an adjacent word in the same cache line. The external agent continues to poll the first word memory location to check when the processor completes its task. The situation is the same in the first example, because the c ","This erratum might create performance issues, or a worst case livelock scenario, if the external agent relies on the automatic visibility of the written data in a finite amount of time. ","The recommended workaround for this erratum is to insert a DMB operation after the faulty write operation in code sequences that this erratum might affect, to ensure the visibility of the written data to any external agent. "
Cortex A-9,r4,p0,C,0,Sticky Pipeline Advance bit cannot be cleared from debug APB accesses,"Cortex-A9, Cortex-A9 MPCore",The Sticky Pipeline Advance bit is bit[25] of the DBGDSCR register. This bit enables the debugger to detect whether the processor is idle. This bit is set to 1 every time the processor pipeline retires one instruction. A write to DBGDRCR[3] clears this bit. The erratum is that the Cortex-A9 does not implement any debug APB access to DBGDRCR[3]. ,-,-,"Because of the erratum, the external debugger cannot clear the Sticky Pipeline Advance bit in the DBGDSCR. In practice, this makes the Sticky Pipeline Advance bit concept unusable on Cortex-A9 processors. ","There is no practical workaround for this erratum. The only possible way to reset the Sticky Pipeline Advance bit is to assert the nDBGRESET input pin on the processor, which obviously has the side effect to reset all debug resources in the concerned processor, and any other additional Coresight components nDBGRESET connects to. "
Cortex A-9,r4,p0,C,0,Some Unallocated memory hint instructions generate an Undefined Instruction exception instead of being treated as NOP,"Cortex-A9, Cortex-A9 MPCore","The ARM Architecture specifies that ARM opcodes of the form 11110 100x001 xxxx xxxx xxxx xxxx xxxx are Unallocated memory hint (treat as NOP) if the core supports the MP extensions, as the Cortex-A9 does. The errata is that the Cortex-A9 generates an Undefined Instruction exception when bits [15:12] of the instruction encoding are different from 4'b1111 , instead of treating the instruction as a NOP. ",-,-,"Because of the erratum, an unexpected Undefined Instruction exception might be generated. In practice, this erratum is unlikely to cause any significant issue because such instruction encodings are not supposed to be generated by any compiler, nor used by any handcrafted program. ","The workaround for this erratum is to modify the instruction encoding with bits[15:12]= 4'b1111 , so that the Cortex-A9 treats the instruction properly as a NOP. If it is not possible to modify the instruction encoding as described, the Undefined Instruction exception handler has to cope with this case, and emulate the expected behavior of the instruction, that is, it must do nothing (NOP), before returning to normal program execution. "
Cortex A-9,r4,p0,C,0,MRC and MCR are not counted in event 0x68,"Cortex-A9, Cortex-A9 MPCore","Event 0x68 counts the total number of instructions passing through the register rename pipeline stage. The erratum is that MRC and MCR instructions are not counted in this event. The event is also reported externally on PMUEVENT[9:8], which suffers from the same defect. ",-,-,"The implication of this erratum is that the values of event 0x68 and PMUEVENT[9:8] are imprecise, omitting the number of MCR and MRC instructions. The inaccuracy of the total count depends on the rate of MRC and MCR instructions in the code. ",No workaround is possible to achieve the required functionality of counting precisely how many instructions are passing through the register rename pipeline stage when the code contains some MRC or MCR instructions. 
Cortex A-9,r4,p0,C,0,Read accesses to DBGPRSR and DBGOSLSR may generate an unexpected Undefined Instruction exception,"Cortex-A9, Cortex-A9 MPCore","CP14 read accesses to the DBGPRSR and DBGOSLSR registers generate an unexpected Undefined Instruction exception when the DBGSWENABLE external pin is set to 0, even when the CP14 accesses are performed from a privileged mode. ",-,-,"Because of the erratum, the DBGPRSR and DBGOSLSR registers are not accessible when DBGSWENABLE=0. This is unlikely to cause any significant issue in Cortex-A9 based systems because these accesses are mainly intended to be used as part of debug over powerdown sequences, and the Cortex-A9 does not support this feature. ",The workaround for this erratum is to temporarily set the DBGSWENABLE bit to 1 so that the DBGPRSR and DBGOSLSR registers can be accessed as expected. There is no other workaround for this erratum. 
Cortex A-9,r4,p0,C,0,Visibility of Debug Enable access rights to enable/disable tracing is not ensured by an ISB,"Cortex-A9, Cortex-A9 MPCore","According to the ARM architecture, any change in the Authentication Status Register should be made visible to the processor after an exception entry or return, or an ISB. Although this is correctly achieved for all debug-related features, the ISB is not sufficient to make the changes visible to the trace flow. As a consequence, the WPTTRACEPROHIBITEDn signal(s) remain stuck to their old value up to the next exception entry or return, or to the next serial branch, even when an ISB executes. A serial branch is one of the following: Data processing to PC with the S bit set (for example, MOVS pc, r14 ) LDM pc ^ ",-,-,"Because of the erratum, the trace flow might not start, nor stop, as expected by the program. ","To work around the erratum, the ISB must be replaced by one of the events causing the change to be visible. In particular, replacing the ISB by a MOVS PC to the next instruction will achieve the correct functionality. "
Cortex A-9,r4,p0,C,0,PMU event 0x0A (exception return) might count twice the LDM PC ^ instructions with base address register write-back,"Cortex-A9, Cortex-A9 MPCore","The LDM PC ^ instructions with base address register write-back might be counted twice in the PMU event 0x0A, which is counting the number of exception returns. The associated PMUEVENT[11] signal is also affected by this erratum, and might be asserted twice by a single LDM PC ^ with base address register write-back. ",-,-,"Because of the erratum, the count of exception returns is imprecise. The error rate depends on the ratio between exception returns of the form LDM PC ^ with base address register write-back and the total number of exceptions returns. ",There is no workaround to this erratum.
Cortex A-9,r4,p0,C,0,Write Context ID event is updated on read access,"Cortex-A9, Cortex-A9 MPCore","When selected, the Write Context ID event (event 0x0B ) of the Performance Monitoring Unit (PMU) increments a counter whenever an instruction that writes to the Context ID register, CONTEXTIDR, is architecturally executed. However, this erratum means that an instruction that reads the Context ID register also updates this counter. ",This erratum affects all configurations of the processor.,"The erratum can happen under the following conditions: 1. A PMU counter is enabled, by setting the PMCNTENSET.Px bit to 1 (x identifies a single event counter, and takes a value from 0 to 7). 2. The “Write Context ID” event is mapped to this selected PMU counter: a. The chosen PMU counter is selected, by setting PMSELR.SEL to x (the same value as in condition 1). b. The Write Context ID event is mapped to this selected PMU, by setting PMXEVTYPER.evtCount to 0x0B . 3. The PMU is enabled, by setting the PMCR.E bit to 1. 4. A read access occurs to the CONTEXTIDR. In this situation the PMU updates the counter when it should not. ","The erratum affects the accuracy of the “Write Context ID” event, and its associated PMUEVENT[12] output signal. ",There is no workaround for this erratum.
Cortex A-9,r4,p0,C,0,DBGPRSR Sticky Reset status bit is set to 1 by the CPU debug reset instead of by the CPU non-debug reset,"Cortex-A9, Cortex-A9 MPCore","DBGPRSR.SR, bit [3], is the Sticky Reset status bit. The ARM architecture specifies that the processor sets this bit to 1 when the non-debug logic of the processor is in reset state. Because of this erratum, the Cortex-A9 processor sets this bit to 1 when the debug logic of the processor is in reset state, instead of when the non-debug logic of the processor is in reset state. ",This erratum affects all configurations of the processor.,-,"Because of the erratum: DBGPRSR.SR might not be set to 1 when it should, when the non-debug logic of the processor is in reset state. DBGPRSR.SR might be set to 1 when it should not, when the debug logic of the processor is in reset state. In both cases, the DBGPRSR.SR bit value might be corrupted, which might prevent the debug logic from correctly detecting when the non-debug logic of the processor has been reset. ",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",A,1,Load or store which fails condition code check might cause deadlock or data corruption,Cortex-A7 MPCore,Under rare circumstances a conditional load instruction which fails its condition code check might cause data corruption or deadlock.,"This erratum does not affect the processor if one of the following is true: The variant and revision reported by the MIDR is r0p3 and REVIDR[1] is set to 1. The variant and revision reported by the MIDR is r0p5 and REVIDR[0] is set to 1. To be affected by this erratum, the Cortex-A7 processor must be configured with VFP or Neon support.","A VFP divide or square root operation is executed. Within the subsequent 58 instructions, a load or store is executed which causes a pipeline stall (caused by a cache miss or memory system contention). Between the VFP divide or square root and the load/store there are none of the following instructions: WFI/WFE An instruction that reads the result of the divide or square root. An instruction that reads the FPSCR. Within the subsequent six instructions a load instruction is executed that satisfies the following requirements: The instruction is conditional. The instruction fails its condition code check. The data addressed by the instruction given correct register inputs crosses an 8-byte boundary (including cases where an alignment fault would have been generated if the instruction had passed its condition code check). Between the earlier load/store instruction and the later load instruction is an instruction which writes to a register used in the address calculation of the load. This instruction must have the opposite condition code to the load instruction. There must be no instructions which set the condition code flags between this instruction and the later load instruction. While the pipeline is stalled due to the earlier load or store, the VFP divide or square root completes. If these conditions are met, then under rare conditions data memory might be corrupted, which might lead to a deadlock. ","It is believed that the various conditions required to cause this erratum are very unlikely to occur together in practice. This erratum has never been observed in deployed products. As such, the practical implications for real systems should be minimal.",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",B,0,Stage 2 XN attribute is suppressed when stage 1 MMU is disabled,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements the ARM Virtualization Extensions. The Virtualization Extensions provide independent translation regimes for memory accesses from different modes. In the Non-secure PL1&0 translation regime, address translation occurs in two stages. Stage 1 maps the Virtual Address (VA) to an Intermediate Physical Address (IPA). Stage 2 maps the IPA to the Physical Address (PA). The ARMv7-A architecture states that if the stage 2 Execute-never (XN) attribute is set to 1, execution from the region is not permitted, regardless of the value of the XN attribute in the stage 1 translation. If a Permission fault is generated because the stage 2 XN bit is set to 1, this is reported as a stage 2 MMU fault. Because of this erratum, the stage 2 XN attribute is suppressed when the stage 1 MMU is disabled. ",All configurations.,The PL1&0 stage 1 MMU is disabled (SCTLR.M is set to 0). 2) The PL1&0 stage 2 MMU is enabled (HCR.VM is set to 1). 3) The CPU is operating in Non-secure state at the PL0 or PL1 privilege level. ,"There are two main implications of this erratum: 1) For code running at Non-secure PL1 in a CPU with the stage 1 MMU disabled, as might occur during the PL1 initialization of a CPU under virtualization, the stage 2 XN attribute does not give any protection from speculative instruction fetches from read-sensitive locations. These locations might rarely be corrupted because of this erratum. 2) For code running at PL0 with HCR.TGE == 1, which permits running an application directly on a hypervisor, the stage 2 XN permission cannot be used to protect areas of memory from being executed. This means that enforcing a security policy in which areas that are writeable are not executable is not possible at EL0 with HCR.TGE == 1.","The first implication can be worked around by ensuring that no read-sensitive locations are mapped into the stage 2 page tables or have read access in the stage 2 page tables when running at Non-secure EL1 with the MMU disabled. The second implication cannot be worked around while HCR.TGE == 1, but it does not lead to functional misbehavior of correctly constructed code. "
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",B,0,Memory locations might be accessed speculatively due to instruction fetches when HCR.VM is set,Cortex-A7 MPCore,"The ARMv7 architecture requires that when all associated stages of translation are disabled for the current privilege level, memory locations are only accessed due to instruction fetches within the same or next 4KB region as an instruction which has been or will be fetched due to sequential execution. In the conditions detailed below, the Cortex-A7 MPCore processor might access other locations speculatively due to instruction fetches. ",All configurations of Cortex-A7 are affected.,1) The processor must be executing at PL2 or Secure PL1. 2) Address translation is disabled for the current exception level (by clearing the appropriate SCTLR.M or HSCTLR.M bit). 3) The HCR.VM bit is set. ,"If these conditions are met, then speculative instruction fetches might be made to memory locations not permitted by the architecture.","Because the HCR.VM bit is reset low, this situation is most likely to arise in powerdown code, if PL2 or Secure PL1 software disables address translation before the core is powered down. To work around this erratum, software should ensure that HCR.VM is cleared before disabling address translation at PL2 or Secure PL1. "
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",B,0,Cache maintenance by set/way operations can execute out of order,Cortex-A7 MPCore,"The v7 ARM ARM states that all cache and branch predictor maintenance operations that do not specify an address execute, relative to each other, in program order. However, because of this erratum, an L2 set/way cache maintenance operation can overtake an L1 set/way cache maintenance operation. ","To be affected by this erratum, the processor must be implemented with an L2 cache.","For this erratum to have an observable effect, the following conditions must be met. 1) A CPU performs an L1 DCCSW or DCCISW operation. 2) The targeted L1 set/way contains dirty data. 3) Before the next DSB, the same CPU executes an L2 DCCSW or DCCISW operation while the L1 set/way operation is in progress. 4) The targeted L2 set/way is within the group of L2 set/ways that the dirty data from L1 can be allocated to. If the above conditions are met then the L2 set/way operation can take effect before the dirty data from L1 has been written to L2. Note: Conditions (3) and (4) are not likely to be met concurrently when performing set/way operations on the entire L1 and L2 caches. This is because cache maintenance code is likely to iterate through sets and ways in a consistent ascending or consistent descending manner across cache levels, and to perform all operations on one cache level before moving on to the next cache level. This means that, for example, cache maintenance operations on L1 set 0 and L2 set 0 will be separated by cache maintenance operations for all other sets in the L1 cache. This creates a large window for the cache maintenance operations on L1 set 0 to complete. ","Code that intends to clean dirty data from L1 to L2 and then from L2 to L3 using set/way operations might not behave as expected. The L2 to L3 operation might happen first and result in dirty data remaining in L2 after the L1 to L2 operation has completed. If dirty data remains in L2 then an external agent, such as a DMA agent, might observe stale data. If the processor is reset or powered-down while dirty data remains in L2 then the dirty data will be lost. ",Correct ordering between set/way cache maintenance operations can be forced by executing a DSB before changing cache levels. 
Cortex -A7 MPCore,r0,"p2,p3,p4",B,0,A CPU can interfere with the duplicate tag RAM invalidation process for another CPU and cause deadlock,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor supports memory coherency between multiple CPUs within the processor, using a duplicate copy of the CPU L1 data tag RAMs in the SCU to filter coherency traffic. The CPU L1 data tag RAMs and duplicate tag RAMs are synchronized by holding L1RSTDISABLE LOW when each CPU is powered up for the first time after full processor power down. The synchronization cannot be performed using software. Because of this erratum, under certain power-up scenarios, the last set of the duplicate tag RAMs can remain inconsistent with the CPU L1 tag RAMs, leading to a deadlock.","This erratum does not affect the processor if one of the following is true: The variant and revision reported by the MIDR is r0p3 and REVIDR[0] is set to 1.  The variant and revision reported by the MIDR is r0p4 and REVIDR[0] is set to 1. To be affected by this erratum, the processor must be implemented with more than one CPU. ","1) The Cortex-A7 MPCore processor is powered down, so that the state of the L1 duplicate tag RAMs is corrupted. 2) The processor is powered up. 3) One of the CPUs within the processor, CPU A, is powered up (possibly at the same time as the processor). Another CPU, CPU B, remains powered down. 4) CPU A performs a cacheable data read, either explicitly due to a load or implicitly due to a prefetch or other cause, that misses in the L1 cache, causing an L1 linefill. 5) CPU B is powered up, causing an invalidation of the L1 duplicate tags for that CPU. 6) Data is returned for the L1 linefill for CPU A. 7) The L1 duplicate tags corresponding to the linefill for CPU A are updated in the same cycle that the tag invalidation sequence for CPU B reaches the last set of the L1 duplicate tag RAMs. If these conditions are met, then the last set of the L1 duplicate tag RAMs for CPU B can be left in a corrupt state. This can lead to the lines in the last set being marked as valid. When CPU B then tries to allocate a line into the last set of the L1 cache, this corrupt data can be interpreted as a valid address. This address can be allocated into a buffer within the processor, but since this address was not valid in the L1 cache, the buffer is never deallocated. When CPU B next issues an operation which requires this buffer, it will wait indefinitely, causing a deadlock. ","This erratum can only affect systems that use a power strategy where the entire Cortex-A7 MPCore processor is powered down, and then on power-up only one CPU is powered up, with other CPUs being powered up only after the first CPU has started executing. In affected systems, the processor can deadlock. ","The system software must ensure that active CPUs do not perform L1 data cache allocations during the tag invalidation process of other CPUs. This is only necessary the first time each CPU is brought out of reset after full processor power down. Three methods to ensure this are described below. Method 1 This method coordinates the tag invalidation process for all CPUs. CPUs that are not required can then be powered down again using the standard power-down sequence. The CPUs can be powered up individually at a later time. 1) On processor power-up power is applied to all CPUs. 2) All CPUs are brought out of reset at the same time. 3) All CPUs complete the normal power-up sequence. 4) CPUs that are not required complete the normal power-down sequence. Method 2 This method is applicable if power control software uses one CPU to initiate power up of other CPUs. In this method, CPU A powers up all other CPUs during CPU A's power-up sequence. CPUs that are not required can then be powered down again using the normal power-down sequence. The CPUs can be powered up individually at a later time. CPU A Initial state: powered down 1) Begin power-up sequence. Do not change SCTLR.C from its reset value of 0. This prevents allocations into the L1 data cache. 2) Clear the 'complete' flag for the power-up process, and clear the 'invalidation done' flags for other CPUs. Flags must be located in separate memory locations so they can be set and cleared individually using non-overlapping stores. 3) Execute a DSB instruction. 4) Initiate power-up of other CPUs. 5) Execute a WFE instruction. 6) On wake-up, check that 'invalidation done' flags have been set by all other CPUs. If a flag is not set, return to WFE state and repeat this step. 7) Set the 'complete' flag. 8) Execute a DSB instruction. 9) Continue the normal power-up sequence. This includes setting SCTLR.C to 1 to enable allocations into the L1 data cache. Other CPUs Initial state: powered down 1) Begin normal power-up sequence. 2) Perform a TLBIMVAIS operation to any address. 3) Execute a DSB instruction. The previous TLBIMVAIS operation requires the DSB to send a DVM Synchronization request. The request will stall until the L1 duplicate tag invalidation process is complete. 4) Set the 'invalidation done' flag. 5) Execute a DSB instruction. 6) Execute a SEV instruction. 7) Execute a WFE instruction. 8) On wake-up, check that the 'complete' flag has been set by CPU A. If the flag is not set, return to WFE state and repeat this step. 9) Continue the normal power-up sequence. 10) Perform the normal power-down sequence if the CPU is not required. Method 3 This method is applicable if power control software uses one CPU to initiate power up of other CPUs, and can send interrupts to all active CPUs. In this method, a CPU is only powered up when it is required. Active CPUs are put into WFE during the power-up sequence of the new CPU. CPU A Initial state: powered up 1) Clear the 'complete' flag for the new CPU power-up process, clear the 'ready' flags for each CPU that is already powered-up, and clear the 'invalidation done' flag for the CPU to be powered-up. Flags must be located in separate memory locations so they can be set and cleared individually using non-overlapping stores. 2) Execute a DSB instruction. 3) Send interrupt to active CPUs. 4) Clear SCTLR.C to 0. This waits for outstanding L1 data cache allocations to complete and then prevents further allocations. The cache contents are preserved and cacheable loads and stores continue to lookup in the cache. 5) Execute an ISB instruction. 6) Execute a DSB instruction. 7) Execute a WFE instruction. 8) On wake-up, check that 'ready' flags have been set by all active CPUs. If a flag is not set, return to WFE state and repeat this step. 9) Initiate power-up of the new CPU. 10) Execute a WFE instruction. 11) On wake-up, check that the 'invalidation done' flag has been set by the new CPU. If the flag has not been set, return to WFE state and repeat this step. 12) Set the 'complete' flag. 13) Execute a DSB instruction. 14) Execute a SEV instruction. 15) Set SCTLR.C to 1. 16) Execute an ISB instruction. 17) Execute a DSB instruction. 18) Continue normal execution. Other active CPUs Initial state: powered up 1) Receive interrupt from CPU A. 2) Clear SCTLR.C to 0. This waits for outstanding L1 data cache allocations to complete and then prevents further allocations. The cache contents are preserved and cacheable loads and stores continue to lookup in the cache. 3) Execute an ISB instruction. 4) Execute a DSB instruction. 5) Set the 'ready' flag. 6) Execute a DSB instruction. 7) Execute a SEV instruction. 8) Execute a WFE instruction. 9) On wake-up, check that the 'complete' flag has been set by CPU A. If the flag is not set, return to WFE state and repeat this step. 10) Set SCTLR.C to 1. 11) Execute an ISB instruction. 12) Execute a DSB instruction. 13) Continue normal execution. New CPU Initial state: powered down 1) Perform the normal power-up sequence. 2) Perform a TLBIMVAIS operation to any address. 3) Execute a DSB instruction. The previous TLBIMVAIS operation requires the DSB to send a DVM Synchronization request. The request will stall until the L1 duplicate tag invalidation process is complete. 4) Set the 'invalidation done' flag. 5) Execute a DSB instruction. 6) Execute a SEV instruction. 7) Continue normal execution."
Cortex -A7 MPCore,r0,"p2,p3,p4",B,0,Domain faults can be incorrectly reported in the PAR for ATS1C* operations executed in Hyp mode executed in Hyp mode,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements the ARM Virtualization Extensions, and therefore implements Hyp mode. When executing in Hyp mode, software can use the ATS1C* operations to perform address translation operations in the context of the Non-secure PL1 modes. The result of an operation is written to the PAR. This erratum means that in some cases the information written to the PAR might be incorrect. ATS12NSO* operations are not affected by this erratum.", All configurations.,"Either: 1) The processor is executing in Hyp mode. 2) HSCTLR.M has the value 0, disabling the PL2 stage 1 MMU. 3) The Non-secure copy of SCTLR.M has the value 1, enabling the PL1&0 stage 1 MMU. 4) The Non-secure copy of TTBCR.EAE has the value 0, selecting use of the Short-descriptor translation table format for PL1&0 stage 1 translations. 5) Software executes an ATS1C* operation to an address which, if accessed from Non-secure PL1, is associated with a domain configured as Manager or No access. or: 1) The processor is executing in Hyp mode. 2) HSCTLR.M has the value 1, enabling the PL2 stage 1 MMU. 3) The Non-secure copy of SCTLR.M has the value 0, disabling the PL1&0 stage 1 MMU. 4) The Non-secure copy of TTBCR.EAE has the value 0, selecting use of the Short-descriptor translation table format for PL1&0 stage 1 translations. 5) The Non-secure copy of DACR.D0 has the value 0b00 or 0b10, configuring domain 0 as No access or using the reserved encoding. 6) Software executes an ATS1C* operation. If the first set of conditions is met then the value written to the PAR will be as if the associated domain for the address were configured as Client. If the second set of conditions is met then the value written to the PAR will erroneously indicate a domain fault. ","Software running in Hyp mode with the PL2 stage 1 MMU disabled can receive incorrect results in the PAR for ATS1C* operations where the PL1&0 stage 1 MMU is enabled. ARM expects that most software executing in Hyp mode will operate with the PL2 stage 1 MMU enabled, and therefore will be unaffected by the first set of conditions described in this erratum. Software running in Hyp mode with the PL2 stage 1 MMU enabled will get erroneous domain faults indicated in the PAR for ATS1C* operations where the PL1&0 stage 1 MMU is disabled. ","Software running in Hyp mode can check the values of HSCTLR.M and the Non-secure copy of SCTLR.M to determine whether they are different. If the values differ, it might be necessary for the Hyp mode software to emulate the ATS1C* operations by directly examining the stage 1 page tables. If the Non-secure copy of SCTLR.M has the value 0 then there is a direct mapping between the virtual address and the intermediate physical address required as the input address for the stage 2 translation. "
Cortex -A7 MPCore,r0,"p2,p3",B,0,Hardware virtual interrupt deactivates incorrect physical interrupt,Cortex-A7 MPCore,The Cortex-A7 MPCore processor can contain an integrated ARM Generic Interrupt Controller (GIC) that supports deactivating the originating physical interrupt when software deactivates a virtual interrupt. Under some circumstances the wrong physical interrupt might be deactivated.,This erratum only affects processors implemented with the GIC.,"Two or more List Registers (GICH_LRn) contain the same VirtualID, of which:  One is an active hardware virtual interrupt, i.e. State==10 and HW==1, and  At least one has a non-zero PhysicalID that is different to the PhysicalID of the active interrupt. If these conditions are met then deactivating the active virtual interrupt might result in the wrong physical interrupt being deactivated. Virtual interrupts can be deactivated using the GICV_EOIR, GICV_AEOIR or GICV_DIR, depending on the value of GICC_CTLR.EOImode and the group of the virtual interrupt. ","If this erratum occurs: the incorrectly deactivated physical interrupt might be signaled to the CPU again the physical interrupt that should have been deactivated, but was not, might never again be signaled to the CPU. ","Software can avoid this erratum by ensuring that when a List Register is programmed with a new virtual interrupt none of the other List Registers hold the same VirtualID field. Two possible methods of achieving this are: 1) When programming a new virtual interrupt, reusing the last List Register that contained the required VirtualID, if it has not since been overwritten with a different VirtualID. 2) Writing all invalid List Registers to 0x0 before programming a new virtual interrupt. "
Cortex -A7 MPCore,r0,p2,B,0,CTIINTACK register needs clearing each time it is set,Cortex-A7 MPCore,"The CTI includes a CTIINTACK register that software can use to acknowledge a trigger instead of using the hardware acknowledge CTITRIGOUTACK signal. The correct operation of this register is that writing a one to the bit corresponding to a trigger output causes that trigger to be cleared, and this does not affect future triggers. Because of this erratum, when a bit in the CTIINTACK register is set to one, it remains set until cleared by writing zero to the register. This causes the corresponding trigger output to be acknowledged immediately if it occurs again, which can lead to the trigger being missed. The CTIINTACK register is normally used in two cases:  To clear a debug related interrupt, if required by the interrupt controller.  To clear a debug entry request generated by another processor, when using cross-halting. ",This erratum affects implementations of the processor that include the integration layer.,The following sequence of conditions must occur: 1) A CTI trigger output fires. 2) The software writes a one to the corresponding bit of the CTI CTIINTACK register to acknowledge the trigger output. 3) The same trigger output fires again before the corresponding bit in the CTIINTACK register is cleared to zero. ,"Trigger outputs might be missed:  In the case of a debug related interrupt that uses CTIINTACK to clear the interrupt, for events other than the first event.  In the case of a cross-halting debug request, after the first time a processor halts and restarts, a subsequent halt might not halt any other processors. ","This is a workaround for tools vendors. When the CTIINTACK register is written with a nonzero value, it must be immediately written to again with the value zero. This prevents any future events on the corresponding trigger output from being acknowledged. If this workaround is used, there remains a race condition, whereby a trigger output that occurs between the two register writes might be lost. This is unlikely to be significant, because the timing of trigger outputs and the timing of register writes are not highly correlated, and if the trigger output had occurred before the first register write, then it would also have been lost. "
Cortex -A7 MPCore,r0,p2,B,0,HSR Incorrect for Advanced SIMD / VFP instructions made UNDEFINED in Hyp mode by HCPTR settings,Cortex-A7 NEON Media Engine,"The Cortex-A7 MPCore Processor implements the ARMv7 Virtualization Extensions and can be implemented to include Advanced SIMD v2 and VFP v4. An Advanced SIMD or VFP instruction made UNDEFINED in Hyp mode by the programming of the HCPTR should write 0x7 to the HSR EC field. Because of this erratum, the Undefined Instruction exception writes 0x0 to the HSR EC field instead.","To be affected by this erratum, the processor implementation must include VFP v4 or Advanced SIMD v2 and VFP v4.",Use of Advanced SIMD and VFP instructions is enabled in the FPEXC register.  The HCPTR is programmed to trap Non-secure use of Advanced SIMD and/or VFP instructions to Hyp mode.  An Advanced SIMD or VFP instruction is executed in Hyp mode. ,"If the HCPTR is used to trap Non-secure use of Advanced SIMD or VFP instructions, the PL2 Undefined Instruction exception handler can not use the value of the HSR EC field to determine if an exception is due to an UNKNOWN cause or an Advanced SIMD or VFP instruction made UNDEFINED because of the programming of the HCPTR.","If an Advanced SIMD or VFP instruction may be UNDEFINED in Hyp mode because of the programming of the HCPTR, the PL2 Undefined Instruction exception handler can not use the value of the HSR EC field to determine whether to check the programming of the HCPTR. The Undefined Instruction exception handler must instead load the UNDEFINED instruction from memory and examine it to determine whether it is an Advanced SIMD or VFP instruction."
Cortex -A7 MPCore,r0,p2,B,0,HSR Incorrect for Advanced SIMD / VFP instructions made UNDEFINED in Hyp mode by HCPTR settings,Cortex-A7 Floating Point Unit,"The Cortex-A7 MPCore Processor implements the ARMv7 Virtualization Extensions and can be implemented to include Advanced SIMD v2 and VFP v4. An Advanced SIMD or VFP instruction made UNDEFINED in Hyp mode by the programming of the HCPTR should write 0x7 to the HSR EC field. Because of this erratum, the Undefined Instruction exception writes 0x0 to the HSR EC field instead.","To be affected by this erratum, the processor implementation must include VFP v4 or Advanced SIMD v2 and VFP v4.",Use of Advanced SIMD and VFP instructions is enabled in the FPEXC register.  The HCPTR is programmed to trap Non-secure use of Advanced SIMD and/or VFP instructions to Hyp mode.  An Advanced SIMD or VFP instruction is executed in Hyp mode. ,"If the HCPTR is used to trap Non-secure use of Advanced SIMD or VFP instructions, the PL2 Undefined Instruction exception handler can not use the value of the HSR EC field to determine if an exception is due to an UNKNOWN cause or an Advanced SIMD or VFP instruction made UNDEFINED because of the programming of the HCPTR.","If an Advanced SIMD or VFP instruction may be UNDEFINED in Hyp mode because of the programming of the HCPTR, the PL2 Undefined Instruction exception handler can not use the value of the HSR EC field to determine whether to check the programming of the HCPTR. The Undefined Instruction exception handler must instead load the UNDEFINED instruction from memory and examine it to determine whether it is an Advanced SIMD or VFP instruction."
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",C,0,"PMU events 0x07, 0x0C, and 0x0E do not increment correctly",Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements version 2 of the Performance Monitor Unit architecture (PMUv2). The PMU can gather statistics on the operation of the processor and memory system during runtime. This event information can be used when debugging or profiling code. The PMU can be programmed to count architecturally executed stores (event 0x07), software changes of the PC (event 0x0C), and procedure returns (event 0x0E). However, because of this erratum, these events do not fully adhere to the descriptions in the PMUv2 architecture. ", All configurations.,"Either: 1) A PMU counter is enabled and programmed to count event 0x07. That is: instruction architecturally executed, condition code check pass, store. 2) A PLDW instruction is executed. If the above conditions are met, the PMUv2 architecture specifies that the counter for event 0x07 does not increment. However, the counter does increment. Or: 1) A PMU counter is enabled and programmed to count event 0x0C. That is: instruction architecturally executed, condition code check pass, software change of the PC. 2) An SVC, HVC, or SMC instruction is executed. If the above conditions are met, the PMUv2 architecture specifies that the counter for event 0x0C increments. However, the counter does not increment. Or: 1) A PMU counter is enabled and programmed to count event 0x0E. That is: instruction architecturally executed, condition code check pass, procedure return. 2) One of the following instructions is executed: 1. MOV PC, LR 2. ThumbEE LDMIA R9!, {?, PC} 3. ThumbEE LDR PC, [R9], #offset 4. BX Rm, where Rm != R14 5. LDM SP, {?, PC} If the above conditions are met, the PMUv2 architecture specifies that the counter for event 0x0E increments for (a), (b), (c) and does not increment for (d) and (e). However, the counter does not increment for (a), (b), (c) and increments for (d) and (e). ","The information returned by PMU counters that are programmed to count events 0x07, 0x0C, or 0x0E might be misleading when debugging or profiling code executed on the processor.",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",C,0,PMU event counter 0x14 does not increment correctly,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements version 2 of the Performance Monitor Unit architecture (PMUv2). The PMU can gather statistics on the operation of the processor and memory system during runtime. This event information can be used when debugging or profiling code. When a PMU counter is programmed to count L1 instruction cache accesses (event 0x14), the counter should increment on all L1 instruction cache accesses. Because of this erratum, the counter increments on cache hits but not on cache misses.", All configurations.,"1) A PMU counter is enabled and programmed to count L1 instruction cache accesses (event 0x14). 2) Cacheable instruction fetches miss in the L1 instruction cache. When the above conditions are met, the event counter will not increment.",A PMU counter that is programmed to count L1 instruction cache accesses will count instruction cache hits but not instruction cache misses. The information returned can be misleading when debugging or profiling code executed on the processor. Cache-bound code execution is not affected by this erratum because of the absence of cache misses.,"To obtain a better approximation for the number of L1 instruction cache accesses, enable a second PMU counter and program it to count instruction fetches that cause linefills (event 0x01). Add the value returned by this counter to the value returned by the L1 instruction access counter (event 0x14). The result of the addition is a better indication of the number of L1 instruction cache accesses."
Cortex -A7 MPCore,r0,"p2,p3,p4,p5",C,0,Exception mask bits are cleared when an exception is taken in Hyp mode,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements the ARM Virtualization Extensions and the ARM Security Extensions. Exceptions can be routed to Monitor mode by setting SCR.{EA, FIQ, IRQ} to 1. Exceptions can be masked by setting corresponding bit CPSR.{A, I, F} to 1. The ARMv7-A architecture states that an exception taken in Hyp mode does not change the value of the mask bits for exceptions routed to Monitor mode. However, because of this erratum, the corresponding mask bits will be cleared to 0.", All configurations.,"1) One or more exception types are routed to Monitor mode by setting one or more of SCR.{EA, FIQ, IRQ} to 1. 2) The corresponding exception types are masked by setting the corresponding CPSR.{A, F, I} bits to 1. 3) Any exception is taken in Hyp mode. If the above conditions are met then the exception mask bit CPSR.{A, F, I} is cleared to 0 for each exception type that meets conditions (1) and (2). The affected mask bits are cleared together regardless of the exception type in condition (3). ","If SCR.{AW, FW} is set to 0 then the clearing of corresponding bit CPSR.{A, F} to 0 has no effect. The value of CPSR.{A, F} is ignored. Otherwise, when CPSR.{A, F, I} is set to 1, Secure code cannot rely on CPSR.{A, F, I} remaining set to 1. An exception that should be masked might be routed to Monitor mode. This is Category C as it is expected that users will: 1) set SCR.{AW, FW} to 0 when SCR.{EA, FIQ} is set to 1. 2) set SCR.IRQ to 0. ",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,"p2,p3,p4",C,0,System instruction accessing CNTPCT or CPACR might be ignored in debug state,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes the Virtualization Extensions, which support trapping system instructions to the hypervisor under certain conditions. Hypervisor traps should be ignored in debug state, but due to this erratum system instructions that access the CNTPCT or CPACR are ignored in debug state if the conditions for generating a hypervisor trap would be met if the processor was not in debug state.", All configurations.,For CNTPCT: 1) The Cortex-A7 MPCore processor is in debug state. 2) The Cortex-A7 MPCore processor is in a Non-secure mode other than Hyp mode. 3) CNTHCTL.PL1PCTEN is set to 1. 4) A system instruction that accesses CNTPCT is executed. For CPACR: 1) The Cortex-A7 MPCore processor is in debug state. 2) The Cortex-A7 MPCore processor is in a non-secure mode other than Hyp mode. 3) HCPTR.TCPAC is set to 1. 4) A system instruction that accesses CPACR is executed. ,A system instruction that accesses the CNTPCT or the CPACR in non-secure state in debug state might have no effect.,"When in debug state, the relevant trap bit (CNTHCL.PL1PCTEN for the CNTPCT and HCPTR.TCPAC for the CPACR) must be cleared to zero before trying to access the CNTPCT or the CPACR."
Cortex -A7 MPCore,r0,"p2,p3,p4",C,0,TBB/TBH incorrect branch address is not mis-predicted,Cortex-A7 MPCore,"The TBB and TBH instructions cause a PC-relative forward branch using a table of single byte or halfword offsets. A base register provides a pointer to the table, and a second register supplies an index into the table. Because of this erratum, the processor might incorrectly calculate the branch offset used to determine whether a predicted branch is correct. In this event, a branch with an address mis-prediction might be treated as a correct branch and cause the processor to execute code from the wrong address.", All configurations.,"1) A load or store instruction with pre-indexed base-register writeback is issued. 2) A TBB or TBH instruction is issued in the cycle after the load or store instruction with the same base-register as the preceding load or store instruction. 3) The TBB or TBH instruction is predicted taken. 4) The load or store instruction and the TBB or TBH instruction pass their condition code checks. 5) The predicted target address is equal to the base-register plus the offset loaded from memory. If the above conditions are met then the processor branches to the base-register plus offset rather than the PC plus offset. Example code sequence: LDR r8, [r0, #0x4]! <independent instruction> TBB [r0, r5] Where <independent instruction> can be one of:  No instruction  NOP  IT  B, BL, BLX (imm)  MOV (reg)  MOV (imm), ADD (imm), SUB (imm), CMP (imm), CMN (imm), AND (imm), EOR (imm), TST (imm), TEQ (imm), BIC (imm), ORR (imm), MVN (imm), ORN (imm), UXTB, UXTB16, UXTH, SXTB, SXTB16, SXTH ","The processor will execute code from the wrong address if permissions are correct. The erratum will not cause the processor to change privilege level or security state. Note: These implications can be safely ignored for compiled C/C++ code because the branch table is opaque to the programmer and C/C++ compilers will not generate the code sequence described in conditions (1) to (4). Similarly, the code sequence is not expected to be generated by other compilers or interpreters. In addition, the 32-bit result of the calculation in condition (5) is unlikely to match the branch target address predicted by the BTAC. This erratum has not been observed in real code. ",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,"p2,p3,p4",C,0,"Debug registers DBGLSR, DBGDEVID, and DBGDEVID1 are only accessible during powerdown if DBGSWENABLE[CPU] is asserted",Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes support for external debug over powerdown as required by the v7.1 Debug Architecture. The v7.1 Debug Architecture states that access to debug registers through the external debug interface is unaffected by the Debug Software Enable function. However, because of this erratum, DBGLSR, DBGDEVID, and DBGDEVID1 are only accessible during powerdown if DBGSWENABLE[CPU] is asserted.","To be affected by this erratum, all of the following must apply:  The processor is built with the integration layer.  The system makes use of debug over powerdown functionality. ","1) DBGSWENABLE[CPU] is not asserted. 2) The processor is powered down. 3) An external debugger reads DBGLSR, DBGDEVID, or DBGDEVID1.","When the conditions are met, the value returned by the read of DBGDEVID, DBGDEVID1, or DBGLSR is zero. For DBGDEVID, this means the read value incorrectly indicates:  DBGEACR, DBGOSDLR, DBGCIDSR, and DBGVIDSR are not present.  DBGPCSR is not implemented as register 40.  The processor does not implement the Virtualization Extensions.  Breakpoint address masking might be implemented.  Watchpoint address masking might be implemented. Architecturally, the correct read value would be 0x01110F13, which indicates:  DBGEACR and DBGOSDLR are present.  DBGPCSR is implemented as register 40.  DBGCIDSR is implemented as register 41.  DBGVIDSR is implemented as register 42.  The processor implements the Virtualization Extensions.  Breakpoint address masking is not implemented.  Watchpoint address masking is implemented. For DBGDEVID1, the read value incorrectly indicates that DBGPCSR samples are offset by a value that depends on the instruction state. Architecturally, the correct read value would be 0x00000001, which indicates that no offset is applied to the DBGPCSR samples. For DBGLSR, zero is the correct read value for an external debug access. Therefore, the effect of DBGSWENABLE[CPU] is only observable if the external debug access is not identified as an external debug access. That is, if PADDRDBG[31] is set to 0 (system) instead of 1 (external debugger). In this scenario, the DBGLSR read value might incorrectly indicate that the Software Lock is clear when it is set. In addition, DBGLSR.SLI, which should be RAO to indicate that Software Lock is implemented, will instead be RAZ. ","The external debugger should read the Main ID Register, MIDR, to determine which processor it is accessing. It should use this information to determine the correct read value for DBGDEVID and DBGDEVID1. Software that makes use of the Software Lock must keep track of whether it has set or cleared the lock. It must not rely on the value returned when DBGLSR is read during powerdown. "
Cortex -A7 MPCore,r0,"p2,p3,p4",C,0,Reads of the DBGPCSR can cause incorrect values to be latched into DBGCIDSR and DBGVIDSR,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor supports sample-based profiling of software. Reads of the DBGPCSR register return the address of a recently-executed instruction, and cause information about the context of the instruction to be latched into DBGCIDSR and DBGVIDSR. Because of this erratum, in some cases the information captured in the DBGCIDSR and DBGVIDSR can be incorrect.", All configurations.,"1) The processor is executing in a state where non-invasive debug is permitted. 2) The processor transitions between Secure and Non-Secure state, or into or out of Hyp mode. 3) Before the processor executes the first instruction after this transition, the DBGPCSR is read. If these conditions are met, then the values sampled into the DBGCIDSR and DBGVIDSR will reflect the new context of the processor, not the context in which the sampled instruction was executed. If the processor transitioned from Non-Secure to Secure state and non-invasive debug is not permitted in Secure state, and the DBGPCSR read is one cycle after the transition, then the DBGCIDSR will be sampled with the value of the secure CONTEXTIDR. ","In cases where sample-based profiling is in use, this erratum can reduce the accuracy of the data. If Secure non-invasive debug is not permitted, then there is a one-cycle window where a Non-secure read could observe the value of the secure CONTEXTIDR. It is not possible for reads issued by the same processor to observe this value, only another processor or agent in the system can perform a read with the required timing. ",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,"p2,p3,p4",C,0,Non-cacheable request event incorrectly counts cacheable instruction accesses,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements version 2 of the Performance Monitor Unit architecture (PMUv2). The PMU provides the ability to gather various statistics on the operation of the processor and memory system during runtime. This event information can be used when debugging or profiling code. Because of this erratum, the Non-cacheable external memory request event provides inaccurate information.", All configurations.,"1) A PMU counter is enabled and programmed to count Non-cacheable external memory requests (event 0xC1). 2) Cacheable instruction fetches miss in the L1 instruction cache, and start L1 linefills. When the above conditions are met, the event counter will increment for each instruction cache linefill, in addition to Non-cacheable instruction and data fetches. ",A PMU counter that is programmed to count Non-cacheable external memory requests might not provide accurate information. The information returned can be misleading when debugging or profiling code executed on the processor.,A PMU counter that is programmed to count Non-cacheable external memory requests might not provide accurate information. The information returned can be misleading when debugging or profiling code executed on the processor.
Cortex -A7 MPCore,r0,"p2,p3",C,0,An instruction fetch can be allocated into the L2 cache after the cache is disabled,Cortex-A7 MPCore,"The SCTLR.C bit controls when data can be allocated to data and unified caches. On a Cortex-A7 processor, instruction fetches can cause lines to be allocated to the L2 cache when the C bit is set to 1. Because of this erratum, an instruction fetch might cause an allocation to the L2 cache when the C bit is set to 0.",This erratum affects configurations of the Cortex-A7 MPCore processor with an L2 cache.,"1) The CPU executes some code while the SCTLR.I and SCTLR.C bits are both set to 1. 2) An instruction cache linefill starts to a 32-byte aligned memory region because of the code being executed. This prompts an L2 linefill to the 64-byte aligned memory region that contains the data required by the instruction cache linefill. 3) The SCTLR.C bit is cleared to 0 to disable the L2 cache. 4) A sequence of DCCSW, DCISW, or DCCISW operations is used to clean or invalidate the entire L1 cache. 5) A sequence of DCCSW, DCISW, or DCCISW operations is used to clean or invalidate the entire L2 cache. 6) The CPU does not attempt to execute code at any address in the last two beats of L2 linefill data before the matching index in the L2 cache is cleaned or invalidated by the sequence of cache maintenance operations. 7) The index in the L2 cache corresponding to the L2 linefill address is cleaned or invalidated by the sequence of cache maintenance operations before the last beat of L2 linefill data is returned from the interconnect. 8) Between disabling the cache, and cleaning or invalidating the cache, the software does not perform a TLB maintenance operation followed by a DSB instruction. If the above conditions are met, and DCISW or DCCISW instructions are used, then after the sequence the L2 cache might incorrectly contain one valid cache line. If the above conditions are met, and DCCSW or DCCISW instructions are used, and the instruction linefill accessed shareable memory, and the interconnect returned dirty data for the linefill, then after the sequence the L2 cache might incorrectly contain one valid cache line with dirty data. ","A clean or invalidate of the entire L2 cache is typically used as part of a powerdown sequence. If the L2 cache contains a dirty line when the processor is powered down, then the data in that line is lost. If the L2 cache contains a clean line when the processor is powered down then no data is lost. Cleaning or invalidating an entire cache is an operation that takes a long time. Depending on the cache size, this can be many thousands of cycles. This erratum requires the response from the interconnect for the instruction linefill to take longer than the L1 cache clean or invalidate, which is unlikely to happen in most systems.","This erratum can be avoided by inserting both of the following after the SCTLR.C bit is cleared to 0, and before the caches are cleaned or invalidated: 1) A TLBIMVA operation to any address. 2) A DSB instruction. "
Cortex -A7 MPCore,r0,"p2,p3",C,0,Loads and stores with mismatched attributes might cause deadlock,Cortex-A7 MPCore,"If the translation tables are constructed such that two or more different virtual addresses map to the same physical address, but the virtual addresses have different memory types, then under certain conditions the processor might deadlock.", All configurations.,"The following conditions must be met, in the order shown, by a single CPU in the processor. 1) The CPU executes a store instruction to Normal memory. The Shareability attribute of the virtual address must be shareable, and the Cacheability attributes must include one of the following: A. Inner Write-Through B. Inner Non-Cacheable and Outer Write-Back or Write-Through 2) The CPU executes a Load Multiple that includes loads to the same cacheline as the store. The Inner Cacheability attribute of the virtual address for this Load Multiple must include Write-Back cacheable. 3) A load in the Load Multiple misses in the L1 cache, causing the cacheline to be allocated before the store from condition 1 completes. ","A deadlock can occur during execution of software which explicitly sets up two or more aliases to the same physical memory page with different inner attributes. It is not expected that many applications make use of mismatched memory types, and in most cases such use is architecturally UNPREDICTABLE.","If multiple aliases to the same physical page in memory are required, place a memory barrier instruction between load or store instructions to the aliased locations."
Cortex -A7 MPCore,r0,"p2,p3",C,0,A read of DBGOSLSR during powerdown returns an incorrect value,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes support for external debug over powerdown as required by the v7.1 Debug Architecture. Because of this erratum, the value returned by a read of the OS Lock Status Register, DBGOSLSR[3:0], is incorrect during powerdown.","To be affected by this erratum, all of the following must apply:  The processor is built with the integration layer. The system makes use of debug over powerdown functionality. ",1) An external debugger reads DBGOSLSR[3:0] when the processor is powered down. ,"When the processor is powered down, a read of DBGOSLSR[3:0] returns incorrect information. The OS Lock Model implementation field, DBGOSLSR.OSLM, reads as 0b11. This is a reserved value with no meaning. It should read as 0b10 to indicate that OS Lock is implemented and DBGOSSRR is not implemented. The not 32-bit access field, DBGOSLSR.nTT, reads as 0b1. It should read as 0b0 to indicate that a 32-bit access is needed to write the key to the OS Lock Access Register. ","When reading DBGOSLSR[3:0], an external debugger must interpret a value of 0b1111 as 0b10x0, where DBGOSLSR.OSLK is UNKNOWN."
Cortex -A7 MPCore,r0,"p2,p3",C,0,A non-cacheable store in a tight loop might not become observable until the loop completes completes,Cortex-A7 MPCore,"The ARM architecture states that all writes complete in a finite period of time in implementations that include the Multiprocessing Extensions. This applies for all writes, including repeated writes to the same location. Because of this erratum, an uninterrupted pattern of stores to the same non-cacheable 64-byte aligned memory region might not become observable to another CPU or master in the system.",This erratum affects all configurations of the Cortex-A7 MPCore processor.,"1) CPU A executes a loop containing one or more stores to the same Normal Non-Cacheable 64-byte aligned memory region. 2) The loop contains fewer than two consecutive instructions that are not stores to the same 64-byte aligned memory region. 3) The loop does not contain any of the following: A. A load to the same 64-byte aligned memory region B. A store to a different 64-byte aligned memory region in Normal Non-Cacheable, Device, or Strongly Ordered memory C. A DMB or DSB instruction D. A Load-Exclusive, Store-Exclusive, or CLREX instruction E. A WFE or WFI instruction F. A CP15 cache or TLB maintenance operation If the above conditions are met, then the repeated stores to the same location might continuously merge inside the CPU until the loop completes on CPU A. ",Another CPU in the processor or another master in the system that reads from the 64-byte aligned memory region might not receive the newest data until the loop completes on CPU A. The erratum is not expected to be observed in real code for the following reasons:  System timers and interrupts will normally change the program flow on CPU A long enough for the stores to become observable.  The last store will become observable to other CPUs and masters when the loop completes on CPU A.  Polled variables that are being updated in a loop are likely to contain a barrier or a power-saving measure such as WFE or WFI.  Loops will normally contain sufficient instructions between stores to the same 64-byte aligned memory region to avoid this issue. ,"A workaround is not expected to be necessary in real code. However, if a workaround is required then the CPU executing the loop can insert any of the instructions mentioned in condition (3) to avoid the erratum. If the software on CPU A cannot be modified then the recommended workaround is to force CPU A to regularly take an interrupt which would act as a watchdog. Several options are possible to generate this regular interrupt, which might be specific to each system. Interrupts generated by the local timer, global timer, or PMU cycle counter overflow are possible candidates. "
Cortex -A7 MPCore,r0,"p2,p3",C,0,Accesses to debug registers when the OS Double Lock is set may result in incorrect behavior,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes support for external debug over powerdown as required by the v7.1 Debug Architecture. As part of the OS Save and Restore mechanism, accesses to most external debug registers are restricted when the OS Double Lock is set. However, because of this erratum, an external access might not result in an error or a write might still occur when an error is returned.",All configurations.,OS Double Lock is set. An external debug access occurs. ,"External writes to debug registers when the OS Double Lock is set might still cause side effects. For example, an attempt to write 1 to DBGPRSR.CWRR when the OS Double Lock is set might cause a core warm reset.","If the OS Double Lock is set on a core in a processor built with the integration layer, the DBGPWRDUP pin for that core should be deasserted LOW. This ensures debug accesses are handled by the debug over powerdown logic in the integration layer rather than by the debug logic in the core."
Cortex -A7 MPCore,r0,"p2,p3",C,0,Accesses to debug data transfer registers when the OS Lock is set behave incorrectly,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes support for external debug over powerdown as required by the v7.1 Debug Architecture. As part of the OS Save and Restore mechanism, the debug data transfer registers should have certain behaviors when the OS Lock is set. However, because of this erratum, the debug data transfer registers do not have the required behaviors when the OS Lock is set.",All configurations.,OS Lock is set. 2) DBGDTRRXext or DBGDTRTXext is read or written. ,"Any state relating to the debug data transfer registers cannot be preserved over powerdown by the OS Save and Restore mechanism. Note the erratum fix only fully corrects the behavior of the debug data transfer registers for the system instructions used by the OS Save and Restore mechanism. The erratum fix incorrectly allows memory-mapped interface accesses to debug data transfer registers to have side effects when the OS Lock is set. However, the expected use model is to use system instructions for OS Save and Restore, and therefore there is no expected problem due to the incompleteness of the erratum fix.",There is no workaround for this erratum.
Cortex -A7 MPCore,r0,p2,C,0,DBGPRCR.CORENPDRQ incorrectly changed on warm reset,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor implements the v7.1 Debug Architecture. This specifies that the DBGPRCR.CORENPDRQ bit should be reset by a core powerup reset only, but because of this erratum it is also reset by a warm reset.","To be affected by this erratum, the processor must be implemented in a system that supports emulation of powerdown.","1) The values of the DBGPRCR.{COREPURQ, CORENPDRQ} bits differ. 2) A warm reset occurs. ","In a system which is affected by this erratum, the Cortex-A7 MPCore processor might report its powerdown emulation request status incorrectly to the power controller after a warm reset.","If a workaround is required, the nature of the workaround depends on which debug solution is used. If an external debugger is used, it should keep the DBGPRCR.COREPURQ bit asserted for as long as emulation of powerdown is required. If self-hosting software is used, its warm reset handler should set the DBGPRCR.CORENPDRQ bit whenever emulation of powerdown is required."
Cortex -A7 MPCore,r0,p2,C,0,CTI Authentication Status register is incorrect,Cortex-A7 MPCore,"The AUTHSTATUS register is a read-only register in the CTI that reports the required security state for debug operations, and the current values of the debug enable signals. The CoreSight Architecture Specification specifies bits [3:0] in the AUTHSTATUS register as follows:  [3:2] NSNID, Non-Secure Non-Invasive Debug  [1:0] NSID, Non-Secure Invasive Debug For each of these fields, the permitted values of the field are: 0b10 Functionality disabled 0b11 Functionality enabled In the CTI, the AUTHSTATUS{NSNID, NSID} fields currently read:  When functionality is disabled - 0b01 As indicated earlier, this should read 0b10. That is, the two bits are reversed.",This erratum affects implementations of the processor that include the integration layer.,Condition 1 The following conditions must apply when reading AUTHSTATUS[1:0] - Non-secure Invasive Debug  The DBGEN input to the CTI is LOW  The AUTHSTATUS register is read Condition 2 The following conditions must apply when reading AUTHSTATUS[3:2] - Non-secure non-Invasive Debug  The NIDEN input to the CTI is LOW  The DBGEN input to the CTI is LOW  The AUTHSTATUS register is read ,"The status of the CTI debug authentication signals returned by the AUTHSTATUS register read is incorrect. The masking of trigger inputs and outputs by DBGEN and NIDEN is not affected by this erratum. However, the return of an incorrect value might lead to incorrect operation of debug tools.","This is a workaround for users and tools vendors. When reading the AUTHSTATUS register, swap the bits in the affected fields and interpret the returned data accordingly. "
Cortex -A7 MPCore,r0,p2,C,0,DBGPRSR[1:0] are incorrectly RAZ during debug over powerdown,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes support for external debug over powerdown as required by the v7.1 Debug Architecture. The architecture states that the value 0b00 for DBGPRSR[1:0], indicating certain of the debug registers cannot be accessed but have not lost their value, is not permitted. However, due to this erratum, a read of these bits during debug over powerdown will return the value 0b00.","To be affected by this erratum, all of the following must apply:  The processor is built with the integration layer.  The system makes use of debug over powerdown functionality. ",1) An external debugger reads DBGPRSR when the processor is powered down.,"When the processor is powered down, the value returned by a read of DBGPRSR[1] incorrectly indicates the processor has not powered down since the last time this register was read.","When reading DBGPRSR[1:0], an external debugger must interpret a value of 0b00 as 0b10. The value 0b10 indicates that the processor is powered down and some debug registers cannot be accessed."
Cortex -A7 MPCore,r0,p2,C,0,DBGDSCRext[15:14] is masked when DBGEN is LOW and OS Lock is SET,Cortex-A7 MPCore,"The Cortex-A7 MPCore processor includes support for external debug over powerdown as required by the v7.1 Debug Architecture. As part of the OS Save and Restore mechanism, software should be able to read the programmed value of DBGDSCRext[15:14] when the OS Lock is set. However, due to this erratum, DBGDSCRext[15:14] is RAZ if invasive debug is disabled when the OS Lock is set.",All configurations in which invasive debug is not permanently disabled.,1) Invasive debug is disabled and the OS Lock is set. 2) DBGDSCRext is read using any of the debug register interfaces. ,"If invasive debug is disabled, when software saves the debug registers prior to a powerdown, it reads and saves zero instead of the programmed value of DBGDSCRext[15:14]. Consequently, when software restores the debug registers after powerdown, it leaves both Monitor and Halting debug-modes disabled rather than in the same state as prior to powerdown.",Ensure invasive debug is enabled when saving the value of the DBGDSCR during OS Save and Restore.
Cortex A-9,r3,p0,A,0,Deadlock on a sequence of cancelled Advanced-SIMD or VFP stores,"Cortex-A9, Cortex-A9 MPCore","A store is cancelled in the following circumstances: if it fails its condition-code if it generates a precise abort if it forms part of speculative execution which is subsequently discarded as a result of the processor identifying a branch miss-predict scenario. A store is queued after the integer core has determined the address of the transaction. A store can optionally not be queued if the integer core can determine that the store will be cancelled while the address computation is being performed, for example if the store is conditional and the CPSR flags are already ready. A store is considered ready when the values of the operands to be stored have been computed. The order in which a sequence of stores become ready can differ from program order if the operation required to compute a result for an earlier store takes longer than that of the result required for a store that occurs later in the program order. A store is considered committed after it is ready and can no longer be cancelled; in other words, after the value to be stored is known, the instruction passes any condition-code check, and any branch-prediction is known to be correct. An Advanced-SIMD (Neon) store, or a VFP store executed as part of a Neon code sequence, can cause deadlock in the following circumstances: 1. The sequence results in the first store in the instruction order becoming ready and committed later than a set of following stores. 2. The subsequent stores become queued so that the second store is cancelled, a third store is committed, and a final store is cancelled. ",-,"Group A is the set of Advanced-SIMD (Neon) or VFP stores whose data fits within a single 64-bit aligned 64-bit memory location, and which are issued by the Neon unit in a single cycle. This group contains all addressing mode forms of: 1. Single-precision 32-bit VFP stores: VSTR.32 2. St,[Rn,...] Neon single D-register structure stores with alignment specifiers equal to 64-bits: VST1.8 {Dd},[Rn@64] VST1.16 {Dd},[Rn@64] VST1.32 {Dd},[Rn@64] VST1.64 {Dd},[Rn@64] 3. Neon indexed single 8-bit element store from one lane: VST1.8 {Dd[<index>]},[Rn] 4. Neon indexed single larger than 8-bit element store from one lane with an alignment specifier: VST1.16 {Dd[<index>]},[Rn@16] VST1.32 {Dd[<index>]},[Rn@32] 5. Neon indexed multi-element store of no more than 8-bytes with an alignment specifier: VST2.8 {Dd[<index>],Dd2[<index>]},[Rn@16] VST2.16 {Dd[<index>],Dd2[<index>]},[Rn@32] VST2.32 {Dd[<index>],Dd2[<index>]},[Rn@64] VST4.8 {Dd[<index>],Dd2[<index>],Dd3[<index>],Dd4[<index>]},[Rn@32] VST4.16 {Dd[<index>],Dd2[<index>],Dd3[<index>],Dd4[<index>]},[Rn@64] The conditions for the erratum arise only when the following sequence occurs: 1. The Advanced-SIMD (Neon) extension is present, enabled and active (see below). 2. A group-A Neon or VFP store is queued, but remains not ready. 3. A Neon or VFP store is queued and cancelled, occupying only one 64-bit slot. 4. A group-A Neon or VFP store is queued and committed. 5. A Neon or VFP store is queued and cancelled. 6. The Neon or VFP store in (2) becomes ready and is committed. Neon is active if an Advanced SIMD (Neon) instruction has been decoded more recently (including speculatively) than an instruction from any of the following categories: 1. A VFP data-processing instruction. 2. A VFP-to-VFP register move (including moving a register to itself as a NOP). 3. A VFP condition code transfer ( VMRS APSR_nzcv, FPSCR , that is FMSTAT). 4. A transfer ( VMSR ) from an integer register to a VFP system register. 5. FLDMX / FSTMX (deprecated). A VFP load/store instruction, or move between VFP and integer registers, has no effect on whether Neon is active. In particular, VFP/Neon register save/restore sequences typically occurring in context switches have no effect on whether Neon is active, unless they use the deprecated FSTMX/FLDMX forms. Neon may be known to be inactive if there have been no Neon instructions decoded (including on any possible speculative paths) since the most recent instruction from one of the above VFP categories. As an example: LDR r5,[r4] CMP r5,r5 ; delayed update of CPSR flags VMUL.U32 d0,d0,d0 ; slow operation updating d0 (s0 and s1) VSTR s0,[r0] ... VSTRNE s2,[r1] ; cancelled ... VSTR s3,[r2] ; committed s4,[r3] ; cancelled ... VSTRNE Note that it is not a requirement for the Neon or VFP store instructions to be consecutive in the program. It is possible to separate these using a number of ARM register based instructions, branches or any other sequence not provided in the workarounds below. In addition the cancelled stores can reside in speculated branch shadows, and might not form part of a simple sequential execution of the same code. This erratum is timing sensitive and is influenced by the relative cycle timings of the CPSR flags, branch prediction results, loads, stores, and both Neon and non-Neon related instructions becoming ready, all of which might not be predictable. ","Only implementations of Cortex-A9, including the Multimedia-Processing Engine (MPE) / Neon unit, are affected by this erratum. Execution of a code sequence that stimulates this erratum ultimately results in deadlock. Neon stores that are committed after the erratum is triggered, but before deadlock occurs, might use the correct address but store out-of-sequence Neon data. ","This erratum does not affect implementations that do not have Neon, or implementations that operate with Neon disabled. You can use the ASEDIS bit to disable the Neon functionality and avoid this erratum, while still retaining VFP floating-point capabilities. You can enable software that uses Neon to work around this erratum by inserting any of the following: One or more Neon or floating-point instructions between conditions 2 and 3. Two or more Neon or floating-point instructions between conditions 3 and 4. One or more Neon or floating-point load instructions between conditions 3 and 4. One or more Neon or floating-point instructions between conditions 4 and 5. When performing code insertion, take care not to re-create an alternative sequence susceptible to this erratum. You can enable software using Neon to work around this erratum by substituting the instructions in Group A with those not from Group A as follows: 1. You can correct instructions that contain alignment specifiers by substitution with the identical instruction minus the alignment specifier. 2. VSTR instructions with zero immediate offset may be code substituted a single word VSTM , for example, VSTR s3,[r0] can be replaced with VSTM r0,{s3} . Note that this code substitution does not provide equivalents for single-lane variant of VST1.8 or for VSTR instructions with non-zero offsets. For these instructions, code insertion remains the preferred corrective action. Suitable instructions for code insertion include, VORR d0,d0,d0 for Neon intensive code and VMOV.F32 s0,s0 for VFP intensive code. Alternatively, you can insert an additional VSTR.F64 to a scratch location. Alternatively, software that does not use Neon can avoid the need to apply the workaround by ensuring that it does not enter the code (including by way of an exception return) with Neon active. For exception returns to software that is not using Neon, you can ensure this by having a VMOV.F32 s0,s0 , or other VFP instruction, that prevents Neon being active (as described above) in the final basic block before the exception return, and by ensuring that the bit pattern immediately following the exception return instruction does not correspond to an instruction that makes Neon active. "
Cortex A-9,r3,p0,A,0,A cancelled Advanced-SIMD or VFP load multiple of more than 8 beats might deadlock ,Cortex-A9 MPCore,"A beat is required for each 64-bit aligned chunk of 64-bits required to service a load. This erratum affects VLDM and VPOP instructions that require more than 8 beats only. This includes all Advanced-SIMD or VFP load multiple instructions which load: greater-than 8 double-word D-register or 16 single-word S-registers from a 64-bit aligned address greater-than 7 double-word D-register or 15 single-word S-registers from a less than 64-bit aligned address. A load is cancelled if it fails its condition code, or if it forms part of speculative execution which is subsequently discarded because the processor identifies a branch miss-predict scenario. A speculative Advanced-SIMD or VFP load multiple of more than eight beats speculatively executed by the Neon unit executed as part of a Neon code sequence, but subsequently cancelled because of miss-speculation, can result in deadlock if followed by a committed Advanced-SIMD or VFP load. ",-,"1. The Advanced-SIMD (Neon) extension is present and enabled. 2. A Neon or VFP load multiple of more than 8-beats is speculatively issued 3. A Neon or VFP load is issued and not cancelled. 4. The Neon or VFP load in (2) is cancelled. As an example: CMP r0,r0 ; ensure EQ condition passes BEQ 1 ; conditional branch to VLDR VLDM r0,{d0-d9} ; cancelled due to branch miss-predict ... 1: VLDR s0,[r1] ; executed and not cancelled This erratum is timing sensitive and is influenced by the relative cycle timings of the CPSR flags, branch prediction results, loads, stores, and the Neon, VFP and integer instructions becoming ready, all of which might not be predictable. ",This erratum affects only implementations of Cortex-A9 that include the Multimedia-Processing-Engine (MPE) or Neon unit. Execution of a code sequence that stimulates this erratum might result in deadlock. ,"This erratum does not affect implementations without Neon, or those that operate with Neon disabled. You can use the ASEDIS bit to disable the Neon functionality and avoid this erratum, while still retaining VFP floating-point capabilities. Software that operates with the Advanced-SIMD (Neon) extension enabled and executing Neon software can work around this erratum by splitting load multiples that are capable of generating more than 8-beats into smaller loads. Note that compliance to the AAPCS ensures that, on exit from a public interface, this erratum will not affect a callee restore of the form VPOP {d8-d15} because of the AAPCS requirement for 64-bit stack-alignment. "
Cortex A-9,r3,p0,A,1,Ordering of read accesses to the same memory location might be uncertain ,Cortex-A9 MPCore,"The ARM architecture and the general rules of coherency require reads to the same memory location to be observed in sequential order. Because of some internal replay path mechanisms, the Cortex-A9 can see one read access bypassed by a following read access to the same memory location, thus not observing the values in program order. ",-,"The erratum requires a Cortex-A9 MPCore configuration with two or more processors or more. The erratum can occur only on a processor working in SMP mode, on memory regions marked as Normal Memory Write-Back Shared. ",The erratum causes data coherency failure.,"The majority of multi-processing code examples follow styles that do not expose the erratum. Therefore, this erratum occurs rarely and is likely to affect only very specific areas of code that rely on a read-ordering behavior. There are two possible workarounds for this erratum: The first possible workaround is to use LDREX instead of standard LDR in volatile memory places that require a strict read ordering. The alternative possible workaround is the recommended workaround for tool chains integration. It requires insertion of a DMB between the affected LDR that requires this strict ordering rule. "
Cortex A-9,r3,p0,B,0,Global Timer can send two interrupts for the same event,Cortex-A9 MPCore,"The Global Timer can be programmed to generate an interrupt request to the processor when it reaches a given programmed value. Because of the erratum, when you program the Global Timer to not use the auto-increment feature, it might generate two interrupt requests instead of one. ",-,"The Global Timer Control register is programmed with the following settings: Bit[3] = 1'b0 - Global Timer is programmed in single-shot mode Bit[2] = 1'b1 - Global Timer IRQ generation is enabled Bit[1] = 1'b1 - Global Timer value comparison with Comparator registers is enabled Bit[0] = 1'b1 - Global Timer count is enabled. With these settings, an IRQ is generated to the processor when the Global Timer value reaches the value programmed in the Comparator registers. The Interrupt Handler then performs the following sequence: Read the ICCIAR (Interrupt Acknowledge) register Clear the Global Timer flag Modify the comparator value, to set it to a higher value Write the ICCEOIR (End of Interrupt) register. Under these conditions, because of the erratum the Global Timer might generate a second (spurious) interrupt request to the processor at the end of this Interrupt Handler sequence. ",The erratum creates spurious interrupt requests in the system.,"Because the erratum happens only when the Global Timer is programmed in single-shot mode, that is, when it does not use the auto-increment feature, a first possible workaround is to program the Global Timer to use the auto-increment feature. If this first solution is not possible, a second workaround is to modify the Interrupt Handler to avoid the offending sequence. You can achieve this by clearing the Global Timer flag after incrementing the Comparator register value. The correct code sequence for the Interrupt Handler should then look like the following sequence: Read the ICCIAR (Interrupt Acknowledge) register Modify the comparator value, to set it to a higher value Clear the Global Timer flag Clear the Pending Status information for Interrupt 27 (Global Timer interrupt) in the Distributor of the Interrupt Controller. Write the ICCEOIR (End of Interrupt) register. "
Cortex A-9,r3,p0,B,0,Missed watchpoint on the second part of an unaligned access crossing a page boundary ,"Cortex-A9, Cortex-A9 MPCore","Under rare conditions, a watchpoint might be undetected if it occurs on the second part of an unaligned access that crosses a 4K page boundary and misses in the μTLB for the second part of its request. The erratum requires a previous conditional instruction which accesses the second 4KB memory region (=where the watchpoint is set), which misses in the μTLB, and which is condition failed. The erratum also requires that no other μTLB miss occurs between this conditional failed instruction and the unaligned access, which implies that the unaligned access must hit in the μTLB for the first part of its access ",-,-,A watchpoint does not trigger when it should.,"The erratum might occur in the case when a watchpoint is set on any of the first 3 bytes of a 4KB memory region, and unaligned accesses are not being faulted. The workaround is then to set a guard watchpoint on the last byte of the previous page, and to deal with any false positive matches if they occur. "
Cortex A-9,r3,p0,B,0,Faulty MMU translations following ASID switch,"Cortex-A9, Cortex-A9 MPCore","A microTLB entry might be corrupted following an ASID switch, possibly corrupting subsequent MMU translations. The erratum requires execution of an explicit memory access, which might be speculative. This memory access misses in the TLB and cause a translation table walk. The erratum occurs when the translation table walk starts before the ASID switch code sequence, but completes after the ASID switch code sequence. In this case, a new entry is allocated in the microTLB for the TLB entry for this translation table walk, but corresponding to the old ASID. Because the microTLB does not record the ASID value, the new MMU translation, which should happen with the new ASID following the ASID switch, might hit this stale microTLB entry and become corrupted. Note that there is no Trustzone Security risk because the Security state of the access is held in the microTLB, and cannot be corrupted. ",-,-,The erratum might cause MMU translation corruptions.,"The workaround for this erratum is to add a DSB in the ASID switch code sequence. The ARM architecture only mandates ISB before and after the ASID switch. Adding a DSB before the ASID switch ensures that the page table walk completes before the ASID change, so that no stale entry can be allocated in the microTLB. Modify the examples in the ARM Architecture Reference Manual for synchronizing the change in the ASID and TTBR as follows: 1. The sequence: Change ASID to 0 ISB Change Translation Table Base Register ISB Change ASID to new value Becomes: DSB Change ASID to 0 ISB Change Translation Table Base Register ISB DSB Change ASID to new value 2. The sequence: Change Translation Table Base Register to the global-only mappings ISB Change ASID to new value ISB Change Translation Table Base Register to new value Becomes: Change Translation Table Base Register to the global-only mappings ISB DSB Change ASID to new value ISB Change Translation Table Base Register to new value 3. And the sequence: Set TTBCR.PD0 = 1 ISB Change ASID to new value Change Translation Table Base Register to new value ISB Set TTBCR.PD0 = 0 Becomes: Set TTBCR.PD0 = 1 ISB DSB Change ASID to new value Change Translation Table Base Register to new value ISB Set TTBCR.PD0 = 0 "
Cortex A-9,r3,p0,B,0,Data or unified cache line maintenance by MVA fails on Inner Shareable memory',Cortex-A9 MPCore,"Under certain timing circumstances, a data or unified cache line maintenance operation by MVA that targets an Inner Shareable memory region might fail to propagate to either the Point of Coherency or to the Point of Unification of the system. As a consequence, the visibility of the updated data might not be guaranteed to either the instruction side, in the case of self-modifying code, or to an external non-coherent agent, such as a DMA engine. ",-,"The erratum requires a Cortex-A9 MPCore configuration with two or more processors, working in SMP mode, with the broadcasting of CP15 maintenance operations enabled. The following scenario shows how the erratum can occur: 1. One CPU performs a data or unified cache line maintenance operation by MVA targeting a memory region which is locally dirty. 2. A second CPU issues a memory request targeting this same memory location within the same time frame. A race condition can occur, resulting in the cache operation not being performed to the specified Point of Unification or Point of Coherence. The erratum affects the following maintenance operations: DCIMVAC: Invalidate data or unified cache line by MVA to PoC DCCMVAC: Clean data or unified cache line by MVA to PoC DCCMVAU: Clean data or unified cache line by MVA to PoU DCCIMVAC: Clean and invalidate data or unified cache line by MVA to PoC. The erratum can occur when the second CPU performs any of the following operations: A read request resulting from any Load instruction; the Load might be a speculative one A write request resulting from any Store instruction A data prefetch resulting from a PLD instruction; the PLD might be a speculative one. ","Because it is uncertain whether execution of the cache maintenance operation propagates to either the Point of Unification or the Point of Coherence, stale data might remain in the data cache and not become visible to other agents that should have gained visibility on it. Note that the data remains coherent on the L1 Data side. Any data read from another processor in the Cortex A9 MPCore cluster, or from the ACP, would see the correct data. In the same way, any write on the same cache line from another processor in the Cortex-A9 MPCore cluster, or from the ACP, does not cause a data corruption resulting from a loss of either data. Consequently, the failure can only impact non-coherent agents in the systems. This can be either the instruction cache of the processor, in the case of self-modifying code, or any non-coherent external agent in the system like a DMA. ","Two workarounds are available for this erratum. The first workaround requires the three following elements to be applied altogether: 1. Set bit[0] in the undocumented SCU Diagnostic Control register located at offset 0x30 from the PERIPHBASE address. Setting this bit disables the migratory bit feature. This forces a dirty cache line to be evicted to the lower memory subsystem, which is both the Point of Coherency and the Point of Unification, when it is being read by another processor. Note that this bit can be written, but is always Read as Zero. 2. Insert a DSB instruction before the cache maintenance operation. Note that, if the cache maintenance operation executes within a loop that performs no other memory operations, ARM recommends only adding a DSB before entering the loop. 3. Ensure there is no false sharing (on a cache line size alignment) for self-modifying code or for data produced for external non-coherent agent such as a DMA engine. For systems which cannot prevent false sharing in these regions, this third step can be replaced by performing the sequence of DSB followed by Cache maintenance operation twice. Note that even when all three components of the workaround are in place, the erratum might still occur. However, this would require some extremely rare and complex timing conditions, so that the probability of reaching the point of failure is extremely low. This, and the fact that the erratum requires an uncommon software scenario, explains why this workaround is likely to be a reliable practical solution for most systems. To ARM's knowledge, no failure has been observed in any system when all three components of this workaround have been implemented. For critical systems that cannot cope with the extremely low failure risks associated with the above workaround, a second workaround is possible which involves changing the mapping of the data being accessed so that it is in a Non-Cacheable area. This ensures that the written data remains uncached. This means it is always visible to non-coherent agents in the system, or to the instruction side in the case of self-modifying code, without any need for cache maintenance operation. "
Cortex A-9,r3,p0,B,0,"A data cache maintenance operation which aborts, followed by an ISB, without any DSB in-between may lead to deadlock ","Cortex-A9, Cortex-A9 MPCore","Under certain micro-architectural circumstances, a data cache maintenance operation which aborts, followed by an ISB, with no DSB occurring between these events, might lead to processor deadlock. ",-,"The erratum requires the following conditions: 1. Some write operations are being handled by the processor, and take a long time to complete. The typical situation is when the write operation (STR, STM, ...) has missed in the L1 Data Cache. 2. No memory barrier (DMB or DSB) is inserted between the write operation and the data cache maintenance operation mentioned in condition 3. 3. A data cache maintenance operation is performed, which aborts because of its MMU settings. 4. No memory barrier (DMB or DSB) is inserted between the data cache maintenance operation in condition 3 and the ISB in condition 5. Any other kind of code can be executed here, starting with the abort exception handler following the aborted cache maintenance operation. 5. An ISB instruction is being executed by the processor. 6. No memory barrier (DMB or DSB) is inserted between the ISB in condition 5 and the read or write operation in condition 7. 7. A read or write operation is executed. With the above conditions, an internal Data Side drain request signal might remain sticky, causing the ISB to wait for the Data Side to be empty, which never happens because the last read or write operation waits for the ISB to complete. ",The erratum can lead to processor deadlock.,A simple workaround for this erratum is to add a DSB at the beginning of the abort exception handler.
Cortex A-9,r3,p0,B,0,"A write to Strongly Ordered memory region, followed by a condition-failed LDREX, might deadlock the processor ","Cortex-A9, Cortex-A9 MPCore","Under certain timing circumstances, a processor might deadlock when the execution of a write to a Strongly Ordered memory region is followed by the speculative execution of a Load-Exclusive or a Store-Exclusive instruction that is mis-speculated. The mis-speculation can be due to either the Load-Exclusive or Store-Exclusive instruction being conditional, and failing its condition code check, or to the Load-Exclusive or Store-Exclusive instruction being speculatively executed in the shadow of a mispredicted branch. ",This erratum affects all configurations of the processor.,"The erratum requires the following conditions: The processor executes a write instruction to a Strongly Ordered memory region. The processor speculatively executes a Load-Exclusive or Store-Exclusive instruction that is either: 1. A conditional instruction 2. An instruction in the shadow of a conditional branch. The Load-Exclusive or Store-Exclusive instruction is cancelled because the speculation was incorrect, because either: 1. The conditional Load-Exclusive or Store-Exclusive instruction failed its condition-code check 2. The conditional branch was mispredicted, so that all subsequent instructions speculatively executed must be flushed, including the Load-Exclusive or Store-Exclusive. The erratum also requires additional timing conditions to be met. These are specific to each platform, and are not controllable by software. These timing conditions includes the fact that the response to the Strongly Ordered write from the external memory system must be received at the same time as the mis-speculation is identified in the processor. ",The erratum causes processor deadlock.,"The recommended workaround is to place a DMB instruction before each Load-Exclusive / Store-Exclusive loop sequence, to ensure that no pending write request can interfere with the execution of the Load-Exclusive or Store-Exclusive instructions. The implementation of this workaround can be restricted to code regions which have access to Strongly Ordered memory. "
Cortex A-9,r3,p0,B,0,A short loop including a DMB instruction might cause a denial of service on another processor which executes a CP15 broadcast operation ,Cortex-A9 MPCore,"A processor which continuously executes a short loop containing a DMB instruction might prevent a CP15 operation broadcast by another processor making further progress, causing a denial of service. ",This erratum affects all Cortex-A9 MPCore processors with two or more processors.,"The erratum requires the following conditions: Two or more processors are working in SMP mode (ACTLR.SMP=1) One of the processors continuously executes a short loop containing at least one DMB instruction. Another processor executes a CP15 maintenance operation that is broadcast. This requires that this processor has enabled the broadcasting of CP15 operations (ACTLR.FW=1) For the erratum to occur, the short loop containing the DMB instruction must meet all of the following additional conditions: No more than 10 instructions other than the DMB are executed between each DMB No non-conditional Load or Store, or conditional Load or Store which pass the condition code check, are executed between each DMB When all the conditions for the erratum are met, the short loop is creating a continuous stream of DMB instructions. This might cause a denial of service, by preventing the processor executing the short loop from executing the received broadcast CP15 operation. As a result, the processor that originally executed the broadcast CP15 operation is stalled until the execution of the loop is interrupted. Note that because the process issuing the CP15 broadcast operation cannot complete operation, it cannot enter any debug-mode, and cannot take any interrupt. If the processor executing the short loop also cannot be interrupted, for example if it has disabled its interrupts, or if no interrupts are routed to this processor, this erratum might cause a system livelock. ","The erratum might create performance issues, or in the worst case it might cause a system livelock if the processor executing the DMB is in an infinite loop that cannot be interrupted. ","This erratum can be worked round by setting bit[4] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. This bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x10 MCR p15,0,rt,c15,c0,1 When it is set, this bit causes the DMB instruction to be decoded and executed like a DSB. Using this software workaround is not expected to have any impact on the overall performance of the processor on a typical code base. Other workarounds are also available for this erratum, to either prevent or interrupt the continuous stream of DMB instructions that causes the deadlock. For example: 2-32 Inserting a non-conditional Load or Store instruction in the loop between each DMB Inserting additional instructions in the loop, such as NOPs, to avoid the processor seeing back to back DMB instructions. Making the processor executing the short loop take regular interrupts. "
Cortex A-9,r3,p0,B,0,Speculative instruction fetches with MMU disabled might not comply with architectural requirements ,"Cortex-A9, Cortex-A9 MPCore","When the MMU is disabled, an ARMv7 processor must follow some architectural rules regarding speculative fetches and the addresses to which these can be initiated. These rules avoid potential read accesses to read-sensitive areas. For more information about these rules see the description of Behavior of instruction fetches when all associated MMUs are disabled in the ARM Architecture Reference Manual, ARMv7-A and ARMv7-R edition. A Cortex-A9 processor usually operates with both the MMU and branch prediction enabled. If the processor operates in this condition for any significant amount of time, the Branch Target Address Cache (BTAC) will contain branch predictions. If the MMU is then disabled, but branch prediction remains enabled, these stale BTAC entries can cause the processor to violate the rules for speculative fetches. ",This erratum affects all configurations of the processor.,"The erratum can occur only if the following sequence of conditions is met: 1. MMU and branch prediction are enabled. 2. Branches are executed. 3. MMU is disabled, and branch prediction remains enabled. ","If the above conditions occur, it is possible that after the MMU is disabled, speculative instruction fetches might occur to read-sensitive locations. ","The recommended workaround is to invalidate all entries in the BTAC, by executing an Invalidate Entire Branch Prediction Array (BPIALL) operation followed by a DSB, before disabling the MMU. Another possible workaround is to disable branch prediction when disabling the MMU, and keep branch prediction disabled until the MMU is re-enabled. "
Cortex A-9,r3,p0,B,0,"A write request to Uncacheable, Shareable normal memory region might be executed twice, possibly causing a software synchronisation issue ","Cortex-A9, Cortex-A9 MPCore","Under certain timing circumstances specific to the Cortex-A9 microarchitecture, a write request to an Uncacheable, Shareable Normal memory region might be executed twice, causing the write request to be sent twice on the AXI bus. This might happen when the write request is followed by another write into the same naturally aligned doubleword memory region, without a DMB between the two writes. The repetition of the write usually has no impact on the overall behaviour of the system, unless the repeated write is used for synchronisation purposes. ",This erratum affects all configurations of the processor.,"The erratum requires the following conditions: 1. A write request is performed to an Uncacheable, Shareable Normal memory region. 2. Another write request is performed into the same naturally doubleword aligned memory region. This second write request must not be performed to the exact same bytes as the first store. A write request to Normal memory region is treated as Uncacheable in the following cases: The write request occurs while the Data Cache is disabled. The write request is targeting a memory region marked as Normal Memory Non-Cacheable or Cacheable Write-Through. The write request is targeting a memory region marked as Normal Memory Cacheable Write-Back and Shareable, and the CPU is in AMP mode. ","This erratum might have implications in a multi-master system where control information is passed between several processing elements in memory using a communication variable, for example a semaphore. In such a system, it is common for communication variables to be claimed using a Load-Exclusive/Store-Exclusive, but for the communication variable to be cleared using a non-Exclusive store. This erratum means that the clearing of such a communication variable might occur twice. This might lead to two masters apparently claiming a communication variable, and therefore might cause data corruption to shared data. A scenario in which this might happen is: MOV r1,#0x40; address is double-word aligned, mapped in ; Normal Non-cacheable Shareable memory Loop:LDREXr5, [r1,#0x0]; read the communication variable CMP r5, #0 ; check if 0 STREXEQ r5, r0, [r1]; attempt to store new value CMPEQ r5, #0; test if store succeeded BNE Loop; retry if not DMB ; ensures that all subsequent accesses are observed when ; gaining of the communication variable has been observed ; loads and stores in the critical region can now be performed MOV r2,#0 MOV r0, #0 DMB ; ensure all previous accesses are observed before the ; communication variable is cleared STR r0, [r1]; clear the communication variable with normal store STR r2, [r1,#0x4] ; previous STR might merge and be sent again, which might ; cause undesired release of the communication variable. This scenario is valid when the communication variable is a byte, a half-word, or a word ","There are several possible workarounds: Add a DMB after clearing a communication variable: STR r0, [r1]; clear the communication variable DMB ; ensure the previous STR is complete Also any IRQ or FIQ handler must execute a DMB at the start to ensure as well the clear of any communication variable is complete. Ensure there is no other data using the same naturally aligned 64-bit memory location as the communication variable: ALIGN 64 communication_variable DCD 0 unused_data DCD 0 LDR r1,= communication_variable ARM UAN 0008D ID032315 Use a Store-Exclusive to clear the communication variable, rather than a non-Exclusive store. "
Cortex A-9,r3,p0,B,0,Updating a translation entry to move a page mapping might erroneously cause an unexpected translation fault ,"Cortex-A9, Cortex-A9 MPCore","Under certain conditions specific to the Cortex-A9 micro-architecture, a write operation that updates a Cacheable translation table entry might cause both the old and the new translation entry to be temporarily invisible to translation table walks, thus erroneously causing a translation fault. ",-,"The erratum requires the following conditions to happen: 1. The processor has its Data Cache and MMU enabled. 2. The TTB registers are set to work on Cacheable descriptors memory regions. 3. The processor is updating an existing Cacheable translation table entry, and this write operation hits in the L1 Data Cache. 4. A hardware translation table walk is attempted. The hardware translation table walk can be due to either an Instruction fetch, or to any other instruction execution that requires an address translation, including any load or store operation. This hardware translation walk must attempt to access the entry being updated in condition 2, and that access must hit in the L1 Data Cache. In practice, this scenario can happen when an OS is changing the mapping of a physical page. The OS might have an existing mapping to a physical page (the old mapping), but wants to move the mapping to a new page (the new mapping). To do this, the OS might: 1. Write a new translation entry, without cancelling the old one. At this point the physical page is accessible using either the old mapping or the new mapping. 2. Execute a DSB instruction followed by an ISB instruction pair, to ensure that the new translation entry is fully visible. 3. Remove the old entry. Because of the erratum, this sequence might fail because it can happen that neither the new mapping, nor the old mapping, is visible after the new entry is written, causing a Translation fault. ",The erratum causes a Translation fault.,"The recommended workaround is to perform a clean and invalidate operation on the cache line that contains the translation entry before updating the entry, to ensure that the write operation misses in the Data Cache. This workaround prevents the micro-architectural conditions for the erratum from happening. Interrupts must be temporarily disabled so that no interrupt can be taken between the maintenance operation and the translation entry update. This avoids the possibility of the interrupt service routine bringing the cache line back in the cache. Another possible workaround is to place the translation table entries in Non-Cacheable memory areas, but this workaround is likely to have a noticeable performance penalty. Note that inserting a DSB instruction immediately after writing the new translation table entry significantly reduces the probability of hitting the erratum, but is not a complete workaround. "
Cortex A-9,r3,p0,B,1,Full cache line writes to the same memory region from at least two processors might deadlock the processor ,Cortex-A9 MPCore,"Under very rare circumstances, full cache line writes from at least two processors on cache lines in hazard with other cache accesses might cause arbitration issues in the SCU, leading to processor deadlock. ","This erratum affects the configurations of the processor with three or more active coherent agents, which is either: Two or more processors if the ACP is present. Three or more processors. ","To trigger the erratum, at least three agents need to be working in SMP mode, and accessing coherent memory regions. Two or more processors need to perform full cache line writes, to cache lines which are in hazard with other access requests in the SCU. The hazard in the SCU happens when another processor, or the ACP, is performing a read of or a write to the same cache line. The following example describes one scenario that might cause this deadlock: CPU0 performs a full cache line write to address A, then a full cache line write to address B CPU1 performs a full cache line write to address B, then a full cache line write to address A CPU2 performs read accesses to addresses A and B Under certain rare timing circumstances, the requests might create a loop of dependencies, causing a processor deadlock. ","When the erratum happens, it leads to system deadlock. It is important to note that any scenario leading to this deadlock situation is uncommon. It requires two processors writing full cache lines to a coherent memory region, without taking any semaphore, with another processor or the ACP accessing the same lines at the same time, meaning that these latter accesses are not deterministic. This, combined with the extremely rare microarchitectural timing conditions under which the defect can happen, explains why the erratum is not expected to cause any significant malfunction in real systems. ","This erratum can be worked round by setting bit[21] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. The bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x200000 MCR p15,0,rt,c15,c0,1 When this bit is set, the direct eviction optimization in the Bus Interface Unit is disabled, which means this erratum cannot occur. Setting this bit might prevent the Cortex-A9 from utilizing the full bandwidth when performing intensive full cache line writes, and therefore a slight performance drop might be visible. In addition, this erratum cannot occur if at least one of the following bits in the Diagnostic Control Register is set to 1: ARM UAN 0008D ID032315 bit [23] - Disable Read-Allocate mode bit [22] - Disable Write Allocate Wait mode "
Cortex A-9,r3,p0,B,1,"Under very rare timing circumstances, transitioning into streaming mode might create a data corruption ",Cortex-A9 MPCore,"Under very rare timing circumstances, a data corruption might occur on a dirty cache line that is evicted from the L1 Data Cache due to another cache line being fully written. ",This erratum affects configurations with either: One processor if the ACP is present Two or more processors ,"The erratum requires the following conditions: The CPU contains a dirty line in its data cache. The CPU performs at least four full cache line writes, one of which causes the eviction of the dirty line. Another CPU, or the ACP, performs a read or write operation on the dirty line. The defect requires very rare timing conditions to reach the point of failure. These timing conditions depend on the CPU micro-architecture and are not controllable in software: The CPU must be in a transitional mode that might be triggered by the detection of the first two full cache line writes. The evicted line must remain stalled in the eviction buffer, which is likely to be caused by congested write traffic. The other coherent agent, either another CPU in the cluster or the ACP, must perform its coherency request on the evicted line while it is in the eviction buffer. ",The erratum might lead to data corruption.,"This erratum can be worked round by setting bit[22] of the undocumented Diagnostic Control Register to 1. This register is encoded as CP15 c15 0 c0 1. The bit can be written in Secure state only, with the following Read/Modify/Write code sequence: MRC p15,0,rt,c15,c0,1 ORR rt,rt,#0x00400000 MCR p15,0,rt,c15,c0,1 When this bit is set, the processor is unable to switch into Read-Allocate (streaming) mode, which means this erratum cannot occur. Setting this bit could possibly result in a visible drop in performance for routines that perform intensive memory accesses, such as memset() or memcpy(). However, the workaround is not expected to create any significant performance degradation in most standard applications. "
Cortex A-9,r3,p0,C,0,ISB is counted in Performance Monitor events 0x0C and 0x0D,"Cortex-A9, Cortex-A9 MPCore","The ISB is implemented as a branch in the Cortex-A9 micro-architecture. This implies that events 0x0C (software change of PC) and 0x0D (immediate branch) are asserted when an ISB occurs, which is not compliant with the ARM Architecture. ",-,-,"The count of events 0x0C and 0x0D are not completely precise when using the Performance Monitor counters, because the ISB is counted together with the real software changes to PC (for 0x0C ) and immediate branches ( 0x0D ). The erratum also causes the corresponding PMUEVENT bits to toggle in case an ISB executes. PMUEVENT[13] relates to event 0x0C PMUEVENT[14] relates to event 0x0D . ","You can count ISB instructions alone with event 0x90 . You can subtract this ISB count from the results you obtained in events 0x0C and 0x0D , to obtain the precise count of software change of PC ( 0x0C ) and immediate branches ( 0x0D ). "
Cortex A-9,r3,p0,C,0,Main ID register alias addresses are not mapped on Debug APB interface,"Cortex-A9, Cortex-A9 MPCore","The ARM Debug Architecture specifies registers 838 and 839 as Alias of the Main ID register. They should be accessible using the APB Debug interface at addresses 0xD18 and 0xD1C . The two alias addresses are not implemented in Cortex-A9. A read access at either of these two addresses returns 0, instead of the MIDR value. Read accesses to these two registers using the internal CP14 interface are trapped to UNDEFINED , which is compliant with the ARM Debug architecture. Therefore the erratum only applies to the alias addresses using the external Debug APB interface. ",-,-,"If the debugger, or any other external agent, tries to read the MIDR register using the alias addresses, it will get a faulty answer ( 0x0 ), which can cause indeterminate errors in the debugger afterwards. ","The workaround for this erratum is to always access the MIDR at its original address, 0xD00 , and not to use its alias address. "
Cortex A-9,r3,p0,C,0,"In debug state, next instruction is stalled when sdabort flag is set, instead of being discarded ","Cortex-A9, Cortex-A9 MPCore","When the processor is in debug state, an instruction written to the ITR after a Load/Store instruction that aborts gets executed on clearing the SDABORT_l, instead of being discarded. ",-,"Debugger has put the extDCCmode bits into Stall mode A previously issued load/store instruction has generated a synchronous Data Abort (for example, an MMU fault) For efficiency, the debugger does not read DBGDSCRext immediately, to see if the load/store has completed and has not aborted, but writes further instructions to the ITR, expecting them to be discarded if a problem occurs The debugger reads the DBGDSCR at the end of the sequence and discovers the load/store aborted The debugger clears the SDABORT_l flag (by writing to the Clear Sticky Aborts bit in DBGDRCR). Under these conditions, the instruction that follows in the ITR might execute instead of being discarded. ","Indeterminate failures can occur because of the instruction being executed when it should not. In most cases, it is unlikely that the failure will cause any significant issue. ","There are a selection of workarounds with increasing complexity and decreasing impact. In each case the impact is a loss of performance when debugging: 1. Do not use stall mode. 2. Do not use stall mode when doing load/store operations. 3. Always check for a sticky abort after issuing a load/store operation in stall mode (the cost of this probably means workaround number 2 is a preferred alternative). 4. Always check for a sticky abort after issuing a load/store operation in stall mode before issuing any further instructions that might corrupt an important target state (such as further load/store instructions, instructions that write to live registers such as VFP, CP15). "
Cortex A-9,r3,p0,C,0,DBGPCSR format is incorrect,"Cortex-A9, Cortex-A9 MPCore","With respect to the DBGPCSR register, the ARM Architecture specifies that: DBGPCSR[31:2] contain the sampled value of bits [31:2] of the PC. The sampled value is an instruction address plus an offset that depends on the processor instruction set state. DBGPCSR[1:0] contain the meaning of PC Sample Value, with the following permitted values: 0b00 ((DBGPCSR[31:2] << 2) 8) references an ARM state instruction 0bx1 ((DBGPCSR[31:1] << 1) 4) references a Thumb or ThumbEE state instruction 0b10 IMPLEMENTATION DEFINED. This field encodes the processor instruction set state, so that the profiling tool can calculate the true instruction address by subtracting the appropriate offset from the value sampled in bits [31:2] of the register. In Cortex-A9, the DBGPCSR samples the target address of executed branches (but possibly still speculative to data aborts), with the following encodings: DBGPCSR[31:2] contain the address of the target branch instruction, with no offset. DBGPCSR[1:0] contains the execution state of the target branch instruction: 0b00 for an ARM state instruction 0b01 for a Thumb state instruction 0b10 for a Jazelle state instruction 0b11 for a ThumbEE state instruction ",-,-,"The implication of this erratum is that the debugger tools must not rely on the architected description for the value of DBGPCSR[1:0], nor remove any offset from DBGPCSR[31:2], to obtain the expected PC value. Subtracting 4 or 8 from the DBGPCSR[31:2] value would lead to an area of code which is unlikely to have been recently executed, or which might not contain any executable code. The same might be true for Thumb instructions at half-word boundaries, in which case PC[1]=1 but DBGPCSR[1]=0, or ThumbEE instructions at word boundaries, with PC[1]=0 and DBGPCSR[1]=1. In Cortex-A9, because the DBGPCSR is always a branch target (= start of a basic block to the tool), the debugger should be able to spot many of these cases and attribute the sample to the right basic block. ","The debugger tools can find the expected PC value and instruction state by reading the DBGPCSR register, and consider it as described in the Description section. "
Cortex A-9,r3,p0,C,0,An imprecise abort might be reported twice on non-cacheable reads,"Cortex-A9, Cortex-A9 MPCore","In the case when two outstanding read memory requests to device or non-cacheable normal memory regions are issued by the Cortex-A9, and the first one receives an imprecise external abort, then the second access might falsely report an imprecise external abort. ",-,The erratum can only happen in systems which can generate imprecise external aborts on device or non-cacheable normal memory regions accesses. ,"When the erratum occurs, a second, spurious imprecise abort might be reported to the core when it should not. In practice, the failure is unlikely to cause any significant issues to the system because imprecise aborts are usually unrecoverable failures. Because the spurious abort can only happen following a first imprecise abort, either the first abort is ignored - and the spurious abort is then ignored too -, or it is acknowledged and probably generates a critical failure in the system, such as a processor reset or whole system reboot. ",There is no practical software workaround for the erratum.
Cortex A-9,r3,p0,C,0,Repeated Store in the same cache line might delay the visibility of the Store,"Cortex-A9, Cortex-A9 MPCore","Since r2p0 revision, the Cortex-A9 implements a small counter which ensures the external visibility of all stores in a finite amount of time, causing an eventual drain of the Merging Store Buffer. This is to avoid erratum #754327, where written data could potentially remain indefinitely in the Store Buffer. This Store Buffer has merging capabilities, and continues to merge data as long as the write accesses are performed in the same cache line. The issue which causes this erratum is that the draining counter resets each time a new data merge is performed. In the case when a code sequence loops, and continues to write data in this same cache line, then the external visibility of the written data might not be ensured. A livelock situation might consequently occur if any external agent is relying on the visibility of the written data, and where the writing processor cannot be interrupted while doing its writing loop. ",-,"The erratum can only happen on Normal Memory regions. The following examples describe scenarios that might trigger the erratum: 1. The processor continues incrementing a counter, writing the same word at the same address. The external agent (possibly another processor) polls on this address, waiting for any update of the counter value to proceed. The Store Buffer continues merging the updated value of the counter in its cache line, so that the external agent never sees any updated value, possibly leading to livelock. 2. The processor writes a value in a given word to indicate completion of its task, then continues writing data in an adjacent word in the same cache line. The external agent continues to poll the first word memory location to check when the processor completes its task. The situation is the same in the first example, because the cache line might remain indefinitely in the merging Store Buffer, creating a possible livelock in the system. ","This erratum might create performance issues, or a worst case livelock scenario, if the external agent relies on the automatic visibility of the written data in a finite amount of time. ","The recommended workaround for this erratum is to insert a DMB operation after the faulty write operation in code sequences that this erratum might affect, to ensure the visibility of the written data to any external agent. "
Cortex A-9,r3,p0,C,0,Sticky Pipeline Advance bit cannot be cleared from debug APB accesses,"Cortex-A9, Cortex-A9 MPCore",The Sticky Pipeline Advance bit is bit[25] of the DBGDSCR register. This bit enables the debugger to detect whether the processor is idle. This bit is set to 1 every time the processor pipeline retires one instruction. A write to DBGDRCR[3] clears this bit. The erratum is that the Cortex-A9 does not implement any debug APB access to DBGDRCR[3]. ,-,-,"Because of the erratum, the external debugger cannot clear the Sticky Pipeline Advance bit in the DBGDSCR. In practice, this makes the Sticky Pipeline Advance bit concept unusable on Cortex-A9 processors. ","There is no practical workaround for this erratum. The only possible way to reset the Sticky Pipeline Advance bit is to assert the nDBGRESET input pin on the processor, which obviously has the side effect to reset all debug resources in the concerned processor, and any other additional Coresight components nDBGRESET connects to. "
Cortex A-9,r3,p0,C,0,Some Unallocated memory hint instructions generate an Undefined Instruction exception instead of being treated as NOP ,"Cortex-A9, Cortex-A9 MPCore","The ARM Architecture specifies that ARM opcodes of the form 11110 100x001 xxxx xxxx xxxx xxxx xxxx are Unallocated memory hint (treat as NOP) if the core supports the MP extensions, as the Cortex-A9 does. The errata is that the Cortex-A9 generates an Undefined Instruction exception when bits [15:12] of the instruction encoding are different from 4'b1111 , instead of treating the instruction as a NOP. ",-,-,"Because of the erratum, an unexpected Undefined Instruction exception might be generated. In practice, this erratum is unlikely to cause any significant issue because such instruction encodings are not supposed to be generated by any compiler, nor used by any handcrafted program. ","The workaround for this erratum is to modify the instruction encoding with bits[15:12]= 4'b1111 , so that the Cortex-A9 treats the instruction properly as a NOP. If it is not possible to modify the instruction encoding as described, the Undefined Instruction exception handler has to cope with this case, and emulate the expected behavior of the instruction, that is, it must do nothing (NOP), before returning to normal program execution. "
Cortex A-9,r3,p0,C,0,MRC and MCR are not counted in event 0x68,"Cortex-A9, Cortex-A9 MPCore","Event 0x68 counts the total number of instructions passing through the register rename pipeline stage. The erratum is that MRC and MCR instructions are not counted in this event. The event is also reported externally on PMUEVENT[9:8], which suffers from the same defect. ",-,-,"The implication of this erratum is that the values of event 0x68 and PMUEVENT[9:8] are imprecise, omitting the number of MCR and MRC instructions. The inaccuracy of the total count depends on the rate of MRC and MCR instructions in the code. ",No workaround is possible to achieve the required functionality of counting precisely how many instructions are passing through the register rename pipeline stage when the code contains some MRC or MCR instructions. 
Cortex A-9,r3,p0,C,0,Read accesses to DBGPRSR and DBGOSLSR may generate an unexpected Undefined Instruction exception ,"Cortex-A9, Cortex-A9 MPCore","CP14 read accesses to the DBGPRSR and DBGOSLSR registers generate an unexpected Undefined Instruction exception when the DBGSWENABLE external pin is set to 0, even when the CP14 accesses are performed from a privileged mode. ",-,-,"Because of the erratum, the DBGPRSR and DBGOSLSR registers are not accessible when DBGSWENABLE=0. This is unlikely to cause any significant issue in Cortex-A9 based systems because these accesses are mainly intended to be used as part of debug over powerdown sequences, and the Cortex-A9 does not support this feature. ",The workaround for this erratum is to temporarily set the DBGSWENABLE bit to 1 so that the DBGPRSR and DBGOSLSR registers can be accessed as expected. There is no other workaround for this erratum. 
Cortex A-9,r3,p0,C,0,PLD instructions might allocate data in the Data Cache regardless of the Cache Enable bit value ,"Cortex-A9, Cortex-A9 MPCore","PLD instructions prefetch and allocate any data marked as Write-Back (either Write-Allocate or Non-Write-Allocate, Shared or Non-Shared), regardless of the processor configuration settings, including the Data Cache Enable bit value. ",-,-,"Because of this erratum, unexpected memory cacheability aliasing is created which might result in various data consistency issues. In practice, this erratum is unlikely to cause any significant issue. The Data Cache is likely to be enabled as soon as possible in most systems, and not dynamically modified. Therefore, this erratum is likely to impact only boot-up code. This code is usually carefully controlled and does not usually contain any PLD instruction while Data Cache is not enabled. ","If this erratum impacts a system, a software workaround is available which is to set bit [20] in the undocumented Control register, which is placed in CP15 c15 0 c0 1. This bit needs to be written with the following Read/Modify/Write code sequence: MRC p15,0,r0,c15,c0,1 ORR r0,r0,#0x00100000 MCR p15,0,r0,c15,c0,1 Setting this bit causes all PLD instructions to be treated as NOPs, with the consequence that code sequences that usually use the PLDs, such as the memcpy() routine, might suffer from a visible performance drop. Therefore, if this workaround is applied, ARM strongly recommends restricting its use to periods of time where the Data Cache is disabled. "
Cortex A-9,r3,p0,C,0,Visibility of Debug Enable access rights to enable/disable tracing is not ensured by an ISB ,"Cortex-A9, Cortex-A9 MPCore","According to the ARM architecture, any change in the Authentication Status Register should be made visible to the processor after an exception entry or return, or an ISB. Although this is correctly achieved for all debug-related features, the ISB is not sufficient to make the changes visible to the trace flow. As a consequence, the WPTTRACEPROHIBITEDn signal(s) remain stuck to their old value up to the next exception entry or return, or to the next serial branch, even when an ISB executes. A serial branch is one of the following: Data processing to PC with the S bit set (for example, MOVS pc, r14) LDM pc ^ ", -,-,"Because of the erratum, the trace flow might not start, nor stop, as expected by the program.","To work around the erratum, the ISB must be replaced by one of the events causing the change to be visible. In particular, replacing the ISB by a MOVS PC to the next instruction will achieve the correct functionality. "
Cortex A-9,r3,p0,C,0,"Speculative cacheable reads to aborting memory regions clear the internal exclusive monitor, may lead to livelock ","Cortex-A9, Cortex-A9 MPCore","On Cortex-A9, when a cacheable read receives an external abort, the aborted line is allocated as invalid in the Data Cache, and any allocation in the Data Cache clears the internal exclusive monitor. Therefore, if a program executes a LDREX/STREX loop which continues to receive an abort answer in the middle of the LDREX/STREX sequence, then the LDREX/STREX sequence never succeeds, leading to a possible processor livelock. As an example, the following code sequence might exhibit the erratum: loop LDREX ... DSB STREX CMP BNE loop .... LDR (into aborting region) The LDREX/STREX does not succeed on the first pass of the loop, and the BNE is mispredicted, and the LDR afterwards is speculatively executed. Therefore the processor keeps on executing: LDR to aborting region (this speculative LDR now appears before the LDREX & DSB) LDREX DSB STREX The LDR misses in L1, and never gets allocated as valid because it is aborting The LDREX executes, and sets the exclusive monitor The DSB executes. It waits for the LDR to complete, which aborts, causing an allocation (as invalid) in the Data Cache, which clears the exclusive monitor. The STREX executes, but the exclusive monitor is now cleared, so the STREX fails. The BNE might be mispredicted again, therefore the LDR is speculatively executed again, and the code loops back on the same failing LDREX/STREX sequence. ",-,The erratum happens in systems which might generate external aborts in answer to cacheable memory requests.,"If the program reaches a stable state where the internal exclusive monitor continues to be cleared in the middle of the LDREX/STREX sequence, then the processor might encounter a livelock situation. In practice, this scenario is very unlikely to happen because several conditions might prevent it: Normal LDREX/STREX code sequences do not contain any DSB, so it is very unlikely that the system would return the abort answer precisely in the middle of the LDREX/STREX sequence on each iteration. Some external irritators (for example, interrupts) might happen and cause timing changes which might exit the processor from its livelock situation. Branch prediction is usually enabled, so the final branch in the loop is usually predicted correctly after a few iterations of the loop, preventing the speculative LDR from being issued, so that the next iteration of the LDREX/STREX sequence succeeds. ","For this erratum, either of the following workarounds fix the problem: ARM UAN 0008D ID032315 Turn on the branch prediction. Remove the DSB in the middle of the LDREX/STREX sequence. If a DSB is required, ARM recommends that you place it before the LDREX/STREX sequence, and implement the LDREX/STREX sequence as recommended by the ARM architecture. "
Cortex A-9,r3,p0,C,0,PMU event 0x0A (exception return) might count twice the LDM PC ^ instructions with base address register write-back ,"Cortex-A9, Cortex-A9 MPCore","The LDM PC ^ instructions with base address register write-back might be counted twice in the PMU event 0x0A, which is counting the number of exception returns. The associated PMUEVENT[11] signal is also affected by this erratum, and might be asserted twice by a single LDM PC ^ with base address register write-back. ",-,-,"Because of the erratum, the count of exception returns is imprecise. The error rate depends on the ratio between exception returns of the form LDM PC ^ with base address register write-back and the total number of exceptions returns. ",There is no workaround to this erratum.
Cortex A-9,r3,p0,C,0,"A spurious event 0x63, STREX passed, can be reported on an LDREX that is preceded by a write to Strongly Ordered memory region. ","Cortex-A9, Cortex-A9 MPCore","A write to Strongly Ordered memory region, followed by the execution of an LDREX instruction, can cause the STREX passed event to be signaled even if no STREX instruction is executed. As a result, the event 0x63 count might be faulty, reporting too many STREX passed events. This erratum also affects the associated PMUEVENT[27] signal. This signal will report the same spurious events. ",-,"The erratum requires the following conditions: 1. The processor executes a write instruction to a Strongly Ordered memory region. 2. The processor executes an LDREX instruction. 3. No DSB instruction is executed, and there is no exception call or exception return, between the write and the STREX instructions. Under these conditions, if the write instruction to Strongly Ordered memory region receives its acknowledge (BRESP response on AXI) while the LDREX is being executed, the erratum can happen. ","The erratum leads to a faulty count of event 0x63, or incorrect signaling of PMUEVENT[27].",The workaround for this erratum is to insert a DMB or DSB instruction between the write to Strongly Ordered memory region and the LDREX instruction. 
Cortex A-9,r3,p0,C,0,Write Context ID event is updated on read access,"Cortex-A9, Cortex-A9 MPCore","When selected, the Write Context ID event (event 0x0B ) of the Performance Monitoring Unit (PMU) increments a counter whenever an instruction that writes to the Context ID register, CONTEXTIDR, is architecturally executed. However, this erratum means that an instruction that reads the Context ID register also updates this counter. ",This erratum affects all configurations of the processor.,"The erratum can happen under the following conditions: 1. A PMU counter is enabled, by setting the PMCNTENSET.Px bit to 1 (x identifies a single event counter, and takes a value from 0 to 7). 2. The “Write Context ID” event is mapped to this selected PMU counter: a. The chosen PMU counter is selected, by setting PMSELR.SEL to x (the same value as in condition 1). b. The Write Context ID event is mapped to this selected PMU, by setting PMXEVTYPER.evtCount to 0x0B . 3. The PMU is enabled, by setting the PMCR.E bit to 1. 4. A read access occurs to the CONTEXTIDR. In this situation the PMU updates the counter when it should not. ","The erratum affects the accuracy of the “Write Context ID” event, and its associated PMUEVENT[12] output signal. ",There is no workaround to this erratum.
Cortex A-9,r3,p0,C,0,DBGPRSR Sticky Reset status bit is set to 1 by the CPU debug reset instead of by the CPU non-debug reset ,"Cortex-A9, Cortex-A9 MPCore","DBGPRSR.SR, bit [3], is the Sticky Reset status bit. The ARM architecture specifies that the processor sets this bit to 1 when the non-debug logic of the processor is in reset state. Because of this erratum, the Cortex-A9 processor sets this bit to 1 when the debug logic of the processor is in reset state, instead of when the non-debug logic of the processor is in reset state. ",The erratum affects all configurations of the processor.,-,"Because of the erratum: DBGPRSR.SR might not be set to 1 when it should, when the non-debug logic of the processor is in reset state. DBGPRSR.SR might be set to 1 when it should not, when the debug logic of the processor is in reset state. In both cases, the DBGPRSR.SR bit value might be corrupted, which might prevent the debug logic from correctly detecting when the non-debug logic of the processor has been reset. ",There is no workaround to this erratum.